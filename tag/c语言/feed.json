{
    "version": "https://jsonfeed.org/version/1",
    "title": "0110 0011 0111 1001 0110 0010 • All posts by \"c语言\" tag",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "url": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "title": "C语言函数（及漏洞利用）",
            "date_published": "2023-08-24T11:23:15.000Z",
            "content_html": "<p>这里用来记录在 pwn 题中一些 C 语言函数的作用和一些函数的漏洞</p>\n<h1 id=\"1-atol-atoi-atoq\"><a class=\"anchor\" href=\"#1-atol-atoi-atoq\">#</a> 1. atol、 atoi、atoq</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token function\">atol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><pre><code>atoi:  把字符串nptr转换为int\natol:  把字符串nptr转换为 long int/long long int\natoq:  \n</code></pre>\n<h1 id=\"2__readfsqword0x28u\"><a class=\"anchor\" href=\"#2__readfsqword0x28u\">#</a> 2.__readfsqword(0x28u)</h1>\n<p><strong>这段代码是通常用于 alarm 函数，防止调试</strong></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token function\">__readfsbyte</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> <span class=\"token function\">__readfsword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token function\">__readfsdword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">unsigned</span> __int64 <span class=\"token function\">__readfsqword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Offset:<br />\n[in] 从 FS 的开头开始读取的偏移量。</p>\n<p>返回值：位置 FS:[Offset] 处的字节、字、双字或四字（由调用的函数名称指示）的内存内容。</p>\n<h1 id=\"3fopenarg1agr2\"><a class=\"anchor\" href=\"#3fopenarg1agr2\">#</a> 3.fopen(&quot;arg1&quot;,&quot;agr2&quot;)</h1>\n<p>该函数原型：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FILE <span class=\"token operator\">*</span><span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>filename<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//filename-- 这是 C 字符串，包含了要打开的文件名称。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//mode-- 这是 C 字符串，包含了文件访问模式。</span></pre></td></tr></table></figure><p>功能：使用给定的模式 mode 打开 filename 所指向的文件。</p>\n<p>返回值：文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在 error 中。</p>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/17/pPhGVIA.png\" alt=\"\" /></p>\n<h1 id=\"4freadbuffersizecountstream\"><a class=\"anchor\" href=\"#4freadbuffersizecountstream\">#</a> 4.fread(buffer,size,count,stream)</h1>\n<p>功能：从给定输入流 stream 读取最多 count 个对象到数组 buffer 中（相当于以对每个对象调用 size 次 fgetc），把 buffer 当作 unsigned char 数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>\n<p>返回值：</p>\n<pre><code>返回成功读取的对象个数，若出现错误或到达文件末尾，则可能小于count。\n\n若size或count为零，则fread返回零且不进行其他动作。\n\nfread不区分文件尾和错误，因此调用者必须用feof和ferror才能判断发生了什么。\n示例\n</code></pre>\n<ul>\n<li>buffer : 指向要读取的数组中首个对象的指针</li>\n<li>size : 每个对象的大小（单位是字节）</li>\n<li>count : 要读取的对象个数</li>\n<li>stream ：输入流</li>\n</ul>\n<h1 id=\"5-int-sprintfchar-string-char-format-argument\"><a class=\"anchor\" href=\"#5-int-sprintfchar-string-char-format-argument\">#</a> 5. int sprintf(char *string, char *format [,argument,...]);</h1>\n<p><code>将结果打印到字符串中，而printf是直接在命令行上输出</code></p>\n<ul>\n<li>string-- 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li>\n<li>format--format-- 这是字符串，包含了要 <code>被写入到 string 的文本</code> 。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li>\n<li>[argument]...：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li>\n</ul>\n<p>返回值：</p>\n<p>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>\n<p>sprintf 返回以 format 为格式 argument 为内容组成的结果被写入 string 的字节数，结束字符‘\\0’不计入内。即，如果 “Hello” 被写入空间足够大的 string 后，函数 sprintf 返回 5。</p>\n<pre><code>转换字符\n%% 印出百分比符号，不转换。\n%c 字符输出到缓冲区，不转换。\n%d 整数转成十进位。\n%f 倍精确度数字转成浮点数。\n%o 整数转成八进位。\n%s 字符串输出到缓冲区，不转换。\n%x 整数转成小写十六进位。\n%X 整数转成大写十六进位。\n</code></pre>\n<h1 id=\"6memchrconst-void-buf-int-ch-size_t-count\"><a class=\"anchor\" href=\"#6memchrconst-void-buf-int-ch-size_t-count\">#</a> 6.memchr(const void *buf, int ch, size_t count)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf    <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> ch    <span class=\"token punctuation\">,</span>  <span class=\"token class-name\">size_t</span> count<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>功能：从 buf 所指内存区域的前 count 个字节查找字符 ch。</p>\n<p>说明：当第一次遇到字符 ch 时停止查找。如果成功，返回指向字符 ch 的指针；否则返回 NULL。</p>\n<h1 id=\"7memcpyvoid-destin-void-source-unsigned-n\"><a class=\"anchor\" href=\"#7memcpyvoid-destin-void-source-unsigned-n\">#</a> 7.memcpy(void *destin, void *source, unsigned n)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>destin<span class=\"token punctuation\">,</span>   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>source<span class=\"token punctuation\">,</span>    <span class=\"token keyword\">unsigned</span> n<span class=\"token punctuation\">)</span>；</pre></td></tr></table></figure><p>功能：从源 source 所指的内存地址的起始位置开始拷贝 n 个字节到目标 destin 所指的内存地址的起始位置中</p>\n<p>返回值：该函数返回一个指向目标存储区 destin 的指针。</p>\n<ul>\n<li>destin-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>\n<li>source-- 指向要复制的数据源，类型强制转换为 void* 指针。</li>\n<li>n-- 要被复制的字节数。</li>\n</ul>\n<h1 id=\"8char-strcat-char-destination-const-char-source\"><a class=\"anchor\" href=\"#8char-strcat-char-destination-const-char-source\">#</a> 8.char * strcat ( char * destination, const char * source );</h1>\n<p>功能：strcat 的实现模式是将 src 中的所有字符（连同字符串最后的’\\0’一起）加到 dest 字符串中第一个‘\\0’的位置，具体一点说就是将 dest 中第一个’\\0’替换成 src 的第一个字符，然后该’\\0’后的字符替换成 src 的第二个字符，后面以此类推。【把 src 所指向的字符串追加到 dest 所指向的字符串的结尾】</p>\n<p>返回值：该函数返回一个指向最终的目标字符串 dest 的指针。</p>\n<h1 id=\"9fork\"><a class=\"anchor\" href=\"#9fork\">#</a> 9.fork（）</h1>\n<p>fork 被调用一次会返回两次（后面的语句也就判断 2 次），返回 0 代表其是子进程，而在父进程中接到的返回值是子进程的 pid，fork 为负值代表出现错误</p>\n<p>调用 fork 会产生一个子进程，子进程会复制父进程的当前状态，这时两个进程便会开始同时运行，且执行顺序不一定</p>\n<pre><code>子进程的fork（）返回值为0 #第一次返回（不分先后，第一次返回也可能是父进程的fork）\n父进程的fork（）返回值为子进程的pid  #第二次返回\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1aXQyMDE2MTIzMDcwL2FydGljbGUvZGV0YWlscy84MzI4MDEyNQ==\">https://blog.csdn.net/cuit2016123070/article/details/83280125</span></p>\n<h1 id=\"10int-fclose-file-fp-可以利用linux命令重定向标准输入输出控制\"><a class=\"anchor\" href=\"#10int-fclose-file-fp-可以利用linux命令重定向标准输入输出控制\">#</a> 10.int fclose (FILE *fp); 【可以利用 Linux 命令重定向标准输入输出控制】</h1>\n<p>功能：关闭文件输出流（使用 fclose () 函数就可以把 缓冲区内最后剩余的数据输出到内核缓冲区，并释放 文件指针和有关的缓冲区。 ）</p>\n<p>返回值：如果流成功关闭，fclose 返回 0，否则返回 EOF（-1）【关闭成功返回 1】。（如果流为 NULL，而且程序可以继续执行，fclose 设定 error number 给 EINVAL，并返回 EOF。）</p>\n<p>绕过方式：Linux 的  <code>exec（cat [文件名]） 1&gt;&amp;0</code>  ，在 Linux 系统中文件描述符 <code>1为标准输出流，0为标准输入流，2为标准错误（输出到屏幕）</code> ，而通过 <code>&amp;+文件描述符</code> 的方式可以代替文件名，（这里就指向了该终端，所以结果显示在终端上 <code>因为默认打开一个终端后，0，1，2都指向该终端</code> ）</p>\n<h1 id=\"11strtol\"><a class=\"anchor\" href=\"#11strtol\">#</a> 11.strtol()</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> <span class=\"token function\">strtol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>endptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> base<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：将参数 str 所指向的字符串根据给定的 base 转换成一个长整型数（long int 型），base 必须介于 2 和 36 之间（包含），或者是特殊值 0</p>\n<ul>\n<li>str  将要转换成长整型的字符串</li>\n<li>endptr  对类型 char * 的引用（引用 str），其值设置为在 str 中 <code>数值型字符串</code> 的下一个字符（如 123ab，则设置为 ab），用来判断是否转化成功</li>\n<li>base 基数，如果为 0 则会根据字符串的前缀来进行判断进制；如果字符串以 <code>0x</code>  或 <code>0X</code>  开头，则视为十六进制；如果字符串以 <code>0</code>  开头，则视为八进制；否则视为十进制</li>\n</ul>\n<p>返回值：</p>\n<p>返回被转换的长整型数值，如果字符串不符合数字格式，则返回 0；若转换结果超出了 <code>long</code>  整数的表示范围，会产生 <code>溢出</code> ，并设置为 errno 为 ERANGE (可以使用 &lt; srrno.h&gt; 头文件中的 errno 变量来检查是否有溢出发生)</p>\n<p>如果输入字符串不能被完全转换为整数，strtol () 函数将返回转换成功的部分，而 <code> endptr</code>  将指向 <code>未转换</code> 部分的第一个字符。在这个例子中， <code>endptr </code> 是指向字符串 <code>末尾</code> 的 <code>空字符 '\\0'</code> ，表示 <code>整个</code> 输入字符串都被 <code>成功转换</code> 为整数。</p>\n<p>如果输入字符串包含 <code>非数字字符</code> ，例如 &quot;12ab&quot;，那么  <code>endptr</code>  将指向  <code>&quot;ab&quot;</code>  的起始位置，指示 <code>转换失败</code> 。</p>\n<h1 id=\"12scanf\"><a class=\"anchor\" href=\"#12scanf\">#</a> 12.scanf()</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> restrict format<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作用：</p>\n<p>函数 scanf () 是从标准输入流 stdin [1] (标准输入设备，一般指向键盘) 中读内容的通用子程序，可以说明的格式读入多个字符，并保存在对应地址的变量中。<br />\n函数的第一个参数是格式字符串，它指定了输入的格式，并按照格式说明符解析输入对应位置的信息并存储于可变参数列表中对应的指针所指位置。每一个指针要求非空，并且与字符串中的格式符一一顺次对应。</p>\n<p>返回值：</p>\n<p>scanf 函数返回成功读入的数据项数，读入数据时遇到了 “文件结束” 则返回 EOF。</p>\n<p>format 指向的字符串包含的格式指令（只举例一个 s）：</p>\n<p>s 读入一个的字符序列，后面会加上 <code>空字节</code> ，遇到 <code>空白字符</code>  (\\t \\r \\n 空格等) 完成读取。</p>\n<p>% s 表示读字符串，而 % d 表示读整数。格式串的处理顺序为从左到右，格式说明符逐一与变元表中的变元匹配。</p>\n<p>格式命令可以说明最大域宽。 在百分号 (%) 与格式码之间的整数用于限制从对应域读入的最大字符数。例如，希望向 address 读入不多于 20 个字符时，可以书写成如下形式：</p>\n<pre><code>scanf(&quot;%20s&quot;,address);\n</code></pre>\n<p>如果输入流的内容 <code>多于</code>  20 个字符，则下次 scanf () 从 <code>此次停止处</code> 开始读入。 若达到最大域宽前已 <code>遇到空白符</code> ，则对该域的读 <code>立即停止</code> ；此时，scanf () 跳到下一个域。 <code>【这也就是意味着，当读入超过20个字符时，没有空白字符时会继续读入】</code></p>\n<h1 id=\"13memcmp函数\"><a class=\"anchor\" href=\"#13memcmp函数\">#</a> 13.memcmp 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">memcmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>str1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>str2<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>把存储区 str1 和存储区 str2 的前 n 个字节进行比较</p>\n<p>参数：</p>\n<ul>\n<li>str1 -- 指向内存块的指针</li>\n<li>str2 -- 指向内存块的指针</li>\n<li>n -- 要被比较的字节数</li>\n</ul>\n<p>返回值：</p>\n<ul>\n<li>如果返回值 &lt; 0，则表示 str1 小于 str2</li>\n<li>如果返回值 &gt; 0，则表示 str1 大于 str2</li>\n<li>如果返回值 = 0，则表示 str1 等于 str2</li>\n</ul>\n<p>c 语言非 0 即为真，因此必须相等才为假</p>\n<p><code>与strcmp不同，该函数在找到空字符后不会停止比较</code></p>\n<pre><code>比较s1和s2所指向对象的前n个字符，如果都相等，返回0，出现第一个不等的地方，如果s1指向的数大于s2指向的数，返回大于0的数，如果小于，返回小于0的数。\n\n对于这个库函数你是否表示费解，首先，有strcmp和strncmp库函数了，看到memcmp的函数声明是void*，我以为是可以比较任意类型的，比如int，float和double，那这个函数和strcnmp是不是重复了呢？\n\n二者都可以用于字符串的比较，但是二者是有比较大的差异的，因为strncmp是按照字节（byte-wise）比较的，并且比较的过程中会检查是否出现了&quot;\\0&quot;结束符，\n一旦任意一个字符串指针前进过程中遇到结束符，将终止比较。\n而memcmp函数是用于比较两个内存块的内容是否相等。\n如果要比较的对象中包含一些由于边界对齐需求而填入结构对象中的空格、联合 (union)结束的额外空格、字符串所分配的空间未使用完的部分引起的“holes”的话，最好使用memcmp来完成。\n这些“holes”(漏洞)的内容是不确定的，在执行byte-wise比较时结果也是不明确的。\n</code></pre>\n<p>memcmp 是可以比较 int，float，double</p>\n<p>这里的比较是从左往右开始的 <code>假设正确的Canary是0x12345678。您发送作为第一个字节。0x01memcmp会看到这个字节和Canary的第一个字节是匹配的，因此它会认为是正确的,发送0x01 0x23memcmp时会看到前两个字节都与Canary匹配，所以它仍然会认为它们是匹配的</code></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWFuZ2d1YW5nLWl0L3AvNzIzNjg5Ni5odG1s\">https://www.cnblogs.com/yangguang-it/p/7236896.html</span></p>\n<h1 id=\"14-strcat函数\"><a class=\"anchor\" href=\"#14-strcat函数\">#</a> 14. strcat 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strcat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>把 src 所指向的字符串 <code>追加</code> 到 dest 所指向的字符串的 <code>结尾</code></p>\n<p>返回值：</p>\n<p>该函数返回一个指向最终的目标字符串 dest 的指针</p>\n<h1 id=\"15puts函数\"><a class=\"anchor\" href=\"#15puts函数\">#</a> 15.puts 函数</h1>\n<p>puts 函数是 C 语言标准库中的一个函数，用于输出一个字符串并在结尾加上一个 <code>换行符（'\\n'）</code> 。</p>\n<p>当 puts 函数 <code>遇到</code> 字符串结尾的 <code>空字符（'\\0'）</code> 时，它会 <code>停止输出</code> ，因为空字符是 C 语言中字符串的结束标志， <code>意味着可以覆盖原本的空字符来泄露后面的内容</code></p>\n<h1 id=\"16strncmp函数\"><a class=\"anchor\" href=\"#16strncmp函数\">#</a> 16.strncmp 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">strncmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str2<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>把 str1 和 str2 进行比较，最多比较前 n 个字符。</p>\n<p>strncmp () 函数通常用于比较两个字符串，以确定它们是否相等或哪个字符串在字典顺序上更小。</p>\n<p>参数：</p>\n<ul>\n<li>str1 -- 要进行比较的第一个字符串。</li>\n<li>str2 -- 要进行比较的第二个字符串。</li>\n<li>n -- 要比较的最大字符数。</li>\n</ul>\n<p>返回值：</p>\n<ul>\n<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>\n<li>如果返回值 &gt; 0，则表示 str1 大于 str2。</li>\n<li>如果返回值 = 0，则表示 str1 等于 str2。</li>\n</ul>\n<h1 id=\"17mmap函数\"><a class=\"anchor\" href=\"#17mmap函数\">#</a> 17.mmap 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">mmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> start<span class=\"token punctuation\">,</span><span class=\"token class-name\">size_t</span> length<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> prot<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span><span class=\"token class-name\">off_t</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">munmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> start<span class=\"token punctuation\">,</span><span class=\"token class-name\">size_t</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作用：</p>\n<p>mmap 函数将文件映射到进程地址空间，实现直接访问文件内容的功能 (mmap 函数通常用于在内存中分配一块连续的地址空间，并指定相应的权限和属性)</p>\n<p>mmap 将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap 在用户空间映射调用系统中作用很大。</p>\n<p>mmap 必须以页大小为单位进行映射，而内存也只能以页为单位进行映射，若要映射非 PAGE_SIZE 整数倍的地址范围，要先进行内存对齐，强行以 PAGE_SIZE 的倍数大小进行映射</p>\n<p><s> <code>mmap</code>  函数，它开辟了一个可执行地址，返回值就是该地址</s></p>\n<h2 id=\"参数\"><a class=\"anchor\" href=\"#参数\">#</a> 参数</h2>\n<p>参数 start</p>\n<pre><code>指向欲映射的内存起始地址，通常设为 NULL（0），代表让系统自动选定地址，映射成功后返回该地址。\n</code></pre>\n<p>参数 length</p>\n<pre><code>代表将文件中多大的部分映射到内存。\n</code></pre>\n<p>参数 prot</p>\n<pre><code>映射区域的保护方式。可以为以下几种方式的组合：\n\nPROT_EXEC 映射区域可被执行 //1\n\nPROT_READ 映射区域可被读取 //4\n\nPROT_WRITE 映射区域可被写入//2\n\nPROT_NONE 映射区域不能存取\n</code></pre>\n<p>参数 flags</p>\n<pre><code>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。\n\nMAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此标志。\n\nMAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。\n\nMAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。\n\nMAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。\n\nMAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。\n\nMAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。\n</code></pre>\n<p>参数 fd</p>\n<pre><code>要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。\n</code></pre>\n<p>参数 offset</p>\n<pre><code>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。\n</code></pre>\n<p>返回值</p>\n<pre><code>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。\n</code></pre>\n<p>错误代码</p>\n<pre><code>EBADF 参数fd不是有效的文件描述词\n\nEACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用\n\nMAP_SHARED则要有PROT_WRITE以及该文件要能写入。\n\nEINVAL 参数start、length 或offset有一个不合法。\n\nEAGAIN 文件被锁住，或是有太多内存被锁住。\n\nENOMEM 内存不足。\n</code></pre>\n<p>需要注意的是内核并不是实时同步映射区与文件的，相反内核很少主动去同步，除非我们调用了函数 msync 或者关闭映射区（关闭映射区的时候，也不是立即同步的）</p>\n",
            "tags": [
                "pwn",
                "C语言"
            ]
        }
    ]
}