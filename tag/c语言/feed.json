{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog • All posts by \"c语言\" tag",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "url": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "title": "C语言函数（及漏洞利用）",
            "date_published": "2023-08-24T11:23:15.000Z",
            "content_html": "<p>这里用来记录在 pwn 题中一些 C 语言函数的作用和一些函数的漏洞</p>\n<h1 id=\"1-atol-atoi-atoq\"><a class=\"anchor\" href=\"#1-atol-atoi-atoq\">#</a> 1. atol、 atoi、atoq</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token function\">atol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><pre><code>atoi:  把字符串nptr转换为int\natol:  把字符串nptr转换为 long int/long long int\natoq:  \n</code></pre>\n<h1 id=\"2__readfsqword0x28u\"><a class=\"anchor\" href=\"#2__readfsqword0x28u\">#</a> 2.__readfsqword(0x28u)</h1>\n<p><strong>这段代码是通常用于 alarm 函数，防止调试</strong></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token function\">__readfsbyte</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> <span class=\"token function\">__readfsword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token function\">__readfsdword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">unsigned</span> __int64 <span class=\"token function\">__readfsqword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Offset:<br />\n[in] 从 FS 的开头开始读取的偏移量。</p>\n<p>返回值：位置 FS:[Offset] 处的字节、字、双字或四字（由调用的函数名称指示）的内存内容。</p>\n<h1 id=\"3fopenarg1agr2\"><a class=\"anchor\" href=\"#3fopenarg1agr2\">#</a> 3.fopen(&quot;arg1&quot;,&quot;agr2&quot;)</h1>\n<p>该函数原型：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FILE <span class=\"token operator\">*</span><span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>filename<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//filename-- 这是 C 字符串，包含了要打开的文件名称。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//mode-- 这是 C 字符串，包含了文件访问模式。</span></pre></td></tr></table></figure><p>功能：使用给定的模式 mode 打开 filename 所指向的文件。</p>\n<p>返回值：文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在 error 中。</p>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/17/pPhGVIA.png\" alt=\"\" /></p>\n<h1 id=\"4freadbuffersizecountstream\"><a class=\"anchor\" href=\"#4freadbuffersizecountstream\">#</a> 4.fread(buffer,size,count,stream)</h1>\n<p>功能：从给定输入流 stream 读取最多 count 个对象到数组 buffer 中（相当于以对每个对象调用 size 次 fgetc），把 buffer 当作 unsigned char 数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>\n<p>返回值：</p>\n<pre><code>返回成功读取的对象个数，若出现错误或到达文件末尾，则可能小于count。\n\n若size或count为零，则fread返回零且不进行其他动作。\n\nfread不区分文件尾和错误，因此调用者必须用feof和ferror才能判断发生了什么。\n示例\n</code></pre>\n<ul>\n<li>buffer : 指向要读取的数组中首个对象的指针</li>\n<li>size : 每个对象的大小（单位是字节）</li>\n<li>count : 要读取的对象个数</li>\n<li>stream ：输入流</li>\n</ul>\n<h1 id=\"5-int-sprintfchar-string-char-format-argument\"><a class=\"anchor\" href=\"#5-int-sprintfchar-string-char-format-argument\">#</a> 5. int sprintf(char *string, char *format [,argument,...]);</h1>\n<p><code>将结果打印到字符串中，而printf是直接在命令行上输出</code></p>\n<ul>\n<li>string-- 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li>\n<li>format--format-- 这是字符串，包含了要 <code>被写入到 string 的文本</code> 。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li>\n<li>[argument]...：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li>\n</ul>\n<p>返回值：</p>\n<p>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>\n<p>sprintf 返回以 format 为格式 argument 为内容组成的结果被写入 string 的字节数，结束字符‘\\0’不计入内。即，如果 “Hello” 被写入空间足够大的 string 后，函数 sprintf 返回 5。</p>\n<pre><code>转换字符\n%% 印出百分比符号，不转换。\n%c 字符输出到缓冲区，不转换。\n%d 整数转成十进位。\n%f 倍精确度数字转成浮点数。\n%o 整数转成八进位。\n%s 字符串输出到缓冲区，不转换。\n%x 整数转成小写十六进位。\n%X 整数转成大写十六进位。\n</code></pre>\n<h1 id=\"6memchrconst-void-buf-int-ch-size_t-count\"><a class=\"anchor\" href=\"#6memchrconst-void-buf-int-ch-size_t-count\">#</a> 6.memchr(const void *buf, int ch, size_t count)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf    <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> ch    <span class=\"token punctuation\">,</span>  <span class=\"token class-name\">size_t</span> count<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>功能：从 buf 所指内存区域的前 count 个字节查找字符 ch。</p>\n<p>说明：当第一次遇到字符 ch 时停止查找。如果成功，返回指向字符 ch 的指针；否则返回 NULL。</p>\n<h1 id=\"7memcpyvoid-destin-void-source-unsigned-n\"><a class=\"anchor\" href=\"#7memcpyvoid-destin-void-source-unsigned-n\">#</a> 7.memcpy(void *destin, void *source, unsigned n)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>destin<span class=\"token punctuation\">,</span>   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>source<span class=\"token punctuation\">,</span>    <span class=\"token keyword\">unsigned</span> n<span class=\"token punctuation\">)</span>；</pre></td></tr></table></figure><p>功能：从源 source 所指的内存地址的起始位置开始拷贝 n 个字节到目标 destin 所指的内存地址的起始位置中</p>\n<p>返回值：该函数返回一个指向目标存储区 destin 的指针。</p>\n<ul>\n<li>destin-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>\n<li>source-- 指向要复制的数据源，类型强制转换为 void* 指针。</li>\n<li>n-- 要被复制的字节数。</li>\n</ul>\n<h1 id=\"8char-strcat-char-destination-const-char-source\"><a class=\"anchor\" href=\"#8char-strcat-char-destination-const-char-source\">#</a> 8.char * strcat ( char * destination, const char * source );</h1>\n<p>功能：strcat 的实现模式是将 src 中的所有字符（连同字符串最后的’\\0’一起）加到 dest 字符串中第一个‘\\0’的位置，具体一点说就是将 dest 中第一个’\\0’替换成 src 的第一个字符，然后该’\\0’后的字符替换成 src 的第二个字符，后面以此类推。【把 src 所指向的字符串追加到 dest 所指向的字符串的结尾】</p>\n<p>返回值：该函数返回一个指向最终的目标字符串 dest 的指针。</p>\n<h1 id=\"9fork\"><a class=\"anchor\" href=\"#9fork\">#</a> 9.fork（）</h1>\n<p>fork 被调用一次会返回两次（后面的语句也就判断 2 次），返回 0 代表其是子进程，而在父进程中接到的返回值是子进程的 pid，fork 为负值代表出现错误</p>\n<p>调用 fork 会产生一个子进程，子进程会复制父进程的当前状态，这时两个进程便会开始同时运行，且执行顺序不一定</p>\n<pre><code>子进程的fork（）返回值为0 #第一次返回（不分先后，第一次返回也可能是父进程的fork）\n父进程的fork（）返回值为子进程的pid  #第二次返回\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1aXQyMDE2MTIzMDcwL2FydGljbGUvZGV0YWlscy84MzI4MDEyNQ==\">https://blog.csdn.net/cuit2016123070/article/details/83280125</span></p>\n<h1 id=\"10int-fclose-file-fp-可以利用linux命令重定向标准输入输出控制\"><a class=\"anchor\" href=\"#10int-fclose-file-fp-可以利用linux命令重定向标准输入输出控制\">#</a> 10.int fclose (FILE *fp); 【可以利用 Linux 命令重定向标准输入输出控制】</h1>\n<p>功能：关闭文件输出流（使用 fclose () 函数就可以把 缓冲区内最后剩余的数据输出到内核缓冲区，并释放 文件指针和有关的缓冲区。 ）</p>\n<p>返回值：如果流成功关闭，fclose 返回 0，否则返回 EOF（-1）【关闭成功返回 1】。（如果流为 NULL，而且程序可以继续执行，fclose 设定 error number 给 EINVAL，并返回 EOF。）</p>\n<p>绕过方式：Linux 的  <code>exec（cat [文件名]） 1&gt;&amp;0</code>  ，在 Linux 系统中文件描述符 <code>1为标准输出流，0为标准输入流，2为标准错误（输出到屏幕）</code> ，而通过 <code>&amp;+文件描述符</code> 的方式可以代替文件名，（这里就指向了该终端，所以结果显示在终端上 <code>因为默认打开一个终端后，0，1，2都指向该终端</code> ）</p>\n<h1 id=\"11strtol\"><a class=\"anchor\" href=\"#11strtol\">#</a> 11.strtol()</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> <span class=\"token function\">strtol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>endptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> base<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：将参数 str 所指向的字符串根据给定的 base 转换成一个长整型数（long int 型），base 必须介于 2 和 36 之间（包含），或者是特殊值 0</p>\n<ul>\n<li>str  将要转换成长整型的字符串</li>\n<li>endptr  对类型 char * 的引用（引用 str），其值设置为在 str 中 <code>数值型字符串</code> 的下一个字符（如 123ab，则设置为 ab），用来判断是否转化成功</li>\n<li>base 基数，如果为 0 则会根据字符串的前缀来进行判断进制；如果字符串以 <code>0x</code>  或 <code>0X</code>  开头，则视为十六进制；如果字符串以 <code>0</code>  开头，则视为八进制；否则视为十进制</li>\n</ul>\n<p>返回值：</p>\n<p>返回被转换的长整型数值，如果字符串不符合数字格式，则返回 0；若转换结果超出了 <code>long</code>  整数的表示范围，会产生 <code>溢出</code> ，并设置为 errno 为 ERANGE (可以使用 &lt; srrno.h&gt; 头文件中的 errno 变量来检查是否有溢出发生)</p>\n<p>如果输入字符串不能被完全转换为整数，strtol () 函数将返回转换成功的部分，而 <code> endptr</code>  将指向 <code>未转换</code> 部分的第一个字符。在这个例子中， <code>endptr </code> 是指向字符串 <code>末尾</code> 的 <code>空字符 '\\0'</code> ，表示 <code>整个</code> 输入字符串都被 <code>成功转换</code> 为整数。</p>\n<p>如果输入字符串包含 <code>非数字字符</code> ，例如 &quot;12ab&quot;，那么  <code>endptr</code>  将指向  <code>&quot;ab&quot;</code>  的起始位置，指示 <code>转换失败</code> 。</p>\n",
            "tags": [
                "pwn",
                "C语言"
            ]
        }
    ]
}