{
    "version": "https://jsonfeed.org/version/1",
    "title": "0110 0011 0111 1001 0110 0010 • All posts by \"c语言\" tag",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "url": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "title": "C语言函数（及漏洞利用）",
            "date_published": "2023-08-24T11:23:15.000Z",
            "content_html": "<p>这里用来记录在 pwn 题中一些 C 语言函数的作用和一些函数的漏洞</p>\n<h1 id=\"1-atol-atoi-atoq\"><a class=\"anchor\" href=\"#1-atol-atoi-atoq\">#</a> 1. atol、 atoi、atoq</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token function\">atol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><pre><code>atoi:  把字符串nptr转换为int\natol:  把字符串nptr转换为 long int/long long int\natoq:  \n</code></pre>\n<h1 id=\"2__readfsqword0x28u\"><a class=\"anchor\" href=\"#2__readfsqword0x28u\">#</a> 2.__readfsqword(0x28u)</h1>\n<p><strong>这段代码是通常用于 alarm 函数，防止调试</strong></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token function\">__readfsbyte</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> <span class=\"token function\">__readfsword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token function\">__readfsdword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">unsigned</span> __int64 <span class=\"token function\">__readfsqword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Offset:<br />\n[in] 从 FS 的开头开始读取的偏移量。</p>\n<p>返回值：位置 FS:[Offset] 处的字节、字、双字或四字（由调用的函数名称指示）的内存内容。</p>\n<h1 id=\"3fopenarg1agr2\"><a class=\"anchor\" href=\"#3fopenarg1agr2\">#</a> 3.fopen(&quot;arg1&quot;,&quot;agr2&quot;)</h1>\n<p>该函数原型：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FILE <span class=\"token operator\">*</span><span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>filename<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//filename-- 这是 C 字符串，包含了要打开的文件名称。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//mode-- 这是 C 字符串，包含了文件访问模式。</span></pre></td></tr></table></figure><p>功能：使用给定的模式 mode 打开 filename 所指向的文件。</p>\n<p>返回值：文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在 error 中。</p>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/17/pPhGVIA.png\" alt=\"\" /></p>\n<h1 id=\"4freadbuffersizecountstream\"><a class=\"anchor\" href=\"#4freadbuffersizecountstream\">#</a> 4.fread(buffer,size,count,stream)</h1>\n<p>功能：从给定输入流 stream 读取最多 count 个对象到数组 buffer 中（相当于以对每个对象调用 size 次 fgetc），把 buffer 当作 unsigned char 数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>\n<p>返回值：</p>\n<pre><code>返回成功读取的对象个数，若出现错误或到达文件末尾，则可能小于count。\n\n若size或count为零，则fread返回零且不进行其他动作。\n\nfread不区分文件尾和错误，因此调用者必须用feof和ferror才能判断发生了什么。\n示例\n</code></pre>\n<ul>\n<li>buffer : 指向要读取的数组中首个对象的指针</li>\n<li>size : 每个对象的大小（单位是字节）</li>\n<li>count : 要读取的对象个数</li>\n<li>stream ：输入流</li>\n</ul>\n<h1 id=\"5-int-sprintfchar-string-char-format-argument\"><a class=\"anchor\" href=\"#5-int-sprintfchar-string-char-format-argument\">#</a> 5. int sprintf(char *string, char *format [,argument,...]);</h1>\n<p><code>将结果打印到字符串中，而printf是直接在命令行上输出</code></p>\n<ul>\n<li>string-- 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li>\n<li>format--format-- 这是字符串，包含了要 <code>被写入到 string 的文本</code> 。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li>\n<li>[argument]...：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li>\n</ul>\n<p>返回值：</p>\n<p>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>\n<p>sprintf 返回以 format 为格式 argument 为内容组成的结果被写入 string 的字节数，结束字符‘\\0’不计入内。即，如果 “Hello” 被写入空间足够大的 string 后，函数 sprintf 返回 5。</p>\n<pre><code>转换字符\n%% 印出百分比符号，不转换。\n%c 字符输出到缓冲区，不转换。\n%d 整数转成十进位。\n%f 倍精确度数字转成浮点数。\n%o 整数转成八进位。\n%s 字符串输出到缓冲区，不转换。\n%x 整数转成小写十六进位。\n%X 整数转成大写十六进位。\n</code></pre>\n<h1 id=\"6memchrconst-void-buf-int-ch-size_t-count\"><a class=\"anchor\" href=\"#6memchrconst-void-buf-int-ch-size_t-count\">#</a> 6.memchr(const void *buf, int ch, size_t count)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf    <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> ch    <span class=\"token punctuation\">,</span>  <span class=\"token class-name\">size_t</span> count<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>功能：从 buf 所指内存区域的前 count 个字节查找字符 ch。</p>\n<p>说明：当第一次遇到字符 ch 时停止查找。如果成功，返回指向字符 ch 的指针；否则返回 NULL。</p>\n<h1 id=\"7memcpyvoid-destin-void-source-unsigned-n\"><a class=\"anchor\" href=\"#7memcpyvoid-destin-void-source-unsigned-n\">#</a> 7.memcpy(void *destin, void *source, unsigned n)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>destin<span class=\"token punctuation\">,</span>   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>source<span class=\"token punctuation\">,</span>    <span class=\"token keyword\">unsigned</span> n<span class=\"token punctuation\">)</span>；</pre></td></tr></table></figure><p>功能：从源 source 所指的内存地址的起始位置开始拷贝 n 个字节到目标 destin 所指的内存地址的起始位置中</p>\n<p>返回值：该函数返回一个指向目标存储区 destin 的指针。</p>\n<ul>\n<li>destin-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>\n<li>source-- 指向要复制的数据源，类型强制转换为 void* 指针。</li>\n<li>n-- 要被复制的字节数。</li>\n</ul>\n<h1 id=\"8char-strcat-char-destination-const-char-source\"><a class=\"anchor\" href=\"#8char-strcat-char-destination-const-char-source\">#</a> 8.char * strcat ( char * destination, const char * source );</h1>\n<p>功能：strcat 的实现模式是将 src 中的所有字符（连同字符串最后的’\\0’一起）加到 dest 字符串中第一个‘\\0’的位置，具体一点说就是将 dest 中第一个’\\0’替换成 src 的第一个字符，然后该’\\0’后的字符替换成 src 的第二个字符，后面以此类推。【把 src 所指向的字符串追加到 dest 所指向的字符串的结尾】</p>\n<p>返回值：该函数返回一个指向最终的目标字符串 dest 的指针。</p>\n<h1 id=\"9fork\"><a class=\"anchor\" href=\"#9fork\">#</a> 9.fork（）</h1>\n<p>fork 被调用一次会返回两次（后面的语句也就判断 2 次），返回 0 代表其是子进程，而在父进程中接到的返回值是子进程的 pid，fork 为负值代表出现错误</p>\n<p>调用 fork 会产生一个子进程，子进程会复制父进程的当前状态，这时两个进程便会开始同时运行，且执行顺序不一定</p>\n<pre><code>子进程的fork（）返回值为0 #第一次返回（不分先后，第一次返回也可能是父进程的fork）\n父进程的fork（）返回值为子进程的pid  #第二次返回\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1aXQyMDE2MTIzMDcwL2FydGljbGUvZGV0YWlscy84MzI4MDEyNQ==\">https://blog.csdn.net/cuit2016123070/article/details/83280125</span></p>\n<h1 id=\"10int-fclose-file-fp-可以利用linux命令重定向标准输入输出控制\"><a class=\"anchor\" href=\"#10int-fclose-file-fp-可以利用linux命令重定向标准输入输出控制\">#</a> 10.int fclose (FILE *fp); 【可以利用 Linux 命令重定向标准输入输出控制】</h1>\n<p>功能：关闭文件输出流（使用 fclose () 函数就可以把 缓冲区内最后剩余的数据输出到内核缓冲区，并释放 文件指针和有关的缓冲区。 ）</p>\n<p>返回值：如果流成功关闭，fclose 返回 0，否则返回 EOF（-1）【关闭成功返回 1】。（如果流为 NULL，而且程序可以继续执行，fclose 设定 error number 给 EINVAL，并返回 EOF。）</p>\n<p>绕过方式：Linux 的  <code>exec（cat [文件名]） 1&gt;&amp;0</code>  ，在 Linux 系统中文件描述符 <code>1为标准输出流，0为标准输入流，2为标准错误（输出到屏幕）</code> ，而通过 <code>&amp;+文件描述符</code> 的方式可以代替文件名，（这里就指向了该终端，所以结果显示在终端上 <code>因为默认打开一个终端后，0，1，2都指向该终端</code> ）</p>\n<h1 id=\"11strtol\"><a class=\"anchor\" href=\"#11strtol\">#</a> 11.strtol()</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> <span class=\"token function\">strtol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>endptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> base<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：将参数 str 所指向的字符串根据给定的 base 转换成一个长整型数（long int 型），base 必须介于 2 和 36 之间（包含），或者是特殊值 0</p>\n<ul>\n<li>str  将要转换成长整型的字符串</li>\n<li>endptr  对类型 char * 的引用（引用 str），其值设置为在 str 中 <code>数值型字符串</code> 的下一个字符（如 123ab，则设置为 ab），用来判断是否转化成功</li>\n<li>base 基数，如果为 0 则会根据字符串的前缀来进行判断进制；如果字符串以 <code>0x</code>  或 <code>0X</code>  开头，则视为十六进制；如果字符串以 <code>0</code>  开头，则视为八进制；否则视为十进制</li>\n</ul>\n<p>返回值：</p>\n<p>返回被转换的长整型数值，如果字符串不符合数字格式，则返回 0；若转换结果超出了 <code>long</code>  整数的表示范围，会产生 <code>溢出</code> ，并设置为 errno 为 ERANGE (可以使用 &lt; srrno.h&gt; 头文件中的 errno 变量来检查是否有溢出发生)</p>\n<p>如果输入字符串不能被完全转换为整数，strtol () 函数将返回转换成功的部分，而 <code> endptr</code>  将指向 <code>未转换</code> 部分的第一个字符。在这个例子中， <code>endptr </code> 是指向字符串 <code>末尾</code> 的 <code>空字符 '\\0'</code> ，表示 <code>整个</code> 输入字符串都被 <code>成功转换</code> 为整数。</p>\n<p>如果输入字符串包含 <code>非数字字符</code> ，例如 &quot;12ab&quot;，那么  <code>endptr</code>  将指向  <code>&quot;ab&quot;</code>  的起始位置，指示 <code>转换失败</code> 。</p>\n<h1 id=\"12scanf\"><a class=\"anchor\" href=\"#12scanf\">#</a> 12.scanf()</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> restrict format<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作用：</p>\n<p>函数 scanf () 是从标准输入流 stdin [1] (标准输入设备，一般指向键盘) 中读内容的通用子程序，可以说明的格式读入多个字符，并保存在对应地址的变量中。<br />\n函数的第一个参数是格式字符串，它指定了输入的格式，并按照格式说明符解析输入对应位置的信息并存储于可变参数列表中对应的指针所指位置。每一个指针要求非空，并且与字符串中的格式符一一顺次对应。</p>\n<p>返回值：</p>\n<p>scanf 函数返回成功读入的数据项数，读入数据时遇到了 “文件结束” 则返回 EOF。</p>\n<p>format 指向的字符串包含的格式指令（只举例一个 s）：</p>\n<p>s 读入一个的字符序列，后面会加上 <code>空字节</code> ，遇到 <code>空白字符</code>  (\\t \\r \\n 空格等) 完成读取。</p>\n<p>% s 表示读字符串，而 % d 表示读整数。格式串的处理顺序为从左到右，格式说明符逐一与变元表中的变元匹配。</p>\n<p>格式命令可以说明最大域宽。 在百分号 (%) 与格式码之间的整数用于限制从对应域读入的最大字符数。例如，希望向 address 读入不多于 20 个字符时，可以书写成如下形式：</p>\n<pre><code>scanf(&quot;%20s&quot;,address);\n</code></pre>\n<p>如果输入流的内容 <code>多于</code>  20 个字符，则下次 scanf () 从 <code>此次停止处</code> 开始读入。 若达到最大域宽前已 <code>遇到空白符</code> ，则对该域的读 <code>立即停止</code> ；此时，scanf () 跳到下一个域。 <code>【这也就是意味着，当读入超过20个字符时，没有空白字符时会继续读入】</code></p>\n<h1 id=\"13memcmp函数\"><a class=\"anchor\" href=\"#13memcmp函数\">#</a> 13.memcmp 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">memcmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>str1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>str2<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>把存储区 str1 和存储区 str2 的前 n 个字节进行比较</p>\n<p>参数：</p>\n<ul>\n<li>str1 -- 指向内存块的指针</li>\n<li>str2 -- 指向内存块的指针</li>\n<li>n -- 要被比较的字节数</li>\n</ul>\n<p>返回值：</p>\n<ul>\n<li>如果返回值 &lt; 0，则表示 str1 小于 str2</li>\n<li>如果返回值 &gt; 0，则表示 str1 大于 str2</li>\n<li>如果返回值 = 0，则表示 str1 等于 str2</li>\n</ul>\n<p>c 语言非 0 即为真，因此必须相等才为假</p>\n<p><code>与strcmp不同，该函数在找到空字符后不会停止比较</code></p>\n<pre><code>比较s1和s2所指向对象的前n个字符，如果都相等，返回0，出现第一个不等的地方，如果s1指向的数大于s2指向的数，返回大于0的数，如果小于，返回小于0的数。\n\n对于这个库函数你是否表示费解，首先，有strcmp和strncmp库函数了，看到memcmp的函数声明是void*，我以为是可以比较任意类型的，比如int，float和double，那这个函数和strcnmp是不是重复了呢？\n\n二者都可以用于字符串的比较，但是二者是有比较大的差异的，因为strncmp是按照字节（byte-wise）比较的，并且比较的过程中会检查是否出现了&quot;\\0&quot;结束符，\n一旦任意一个字符串指针前进过程中遇到结束符，将终止比较。\n而memcmp函数是用于比较两个内存块的内容是否相等。\n如果要比较的对象中包含一些由于边界对齐需求而填入结构对象中的空格、联合 (union)结束的额外空格、字符串所分配的空间未使用完的部分引起的“holes”的话，最好使用memcmp来完成。\n这些“holes”(漏洞)的内容是不确定的，在执行byte-wise比较时结果也是不明确的。\n</code></pre>\n<p>memcmp 是可以比较 int，float，double</p>\n<p>这里的比较是从左往右开始的 <code>假设正确的Canary是0x12345678。您发送作为第一个字节。0x01memcmp会看到这个字节和Canary的第一个字节是匹配的，因此它会认为是正确的,发送0x01 0x23memcmp时会看到前两个字节都与Canary匹配，所以它仍然会认为它们是匹配的</code></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWFuZ2d1YW5nLWl0L3AvNzIzNjg5Ni5odG1s\">https://www.cnblogs.com/yangguang-it/p/7236896.html</span></p>\n<h1 id=\"14-strcat函数\"><a class=\"anchor\" href=\"#14-strcat函数\">#</a> 14. strcat 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strcat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>把 src 所指向的字符串 <code>追加</code> 到 dest 所指向的字符串的 <code>结尾</code></p>\n<p>返回值：</p>\n<p>该函数返回一个指向最终的目标字符串 dest 的指针</p>\n<h1 id=\"15puts函数\"><a class=\"anchor\" href=\"#15puts函数\">#</a> 15.puts 函数</h1>\n<p>puts 函数是 C 语言标准库中的一个函数，用于输出一个字符串并在结尾加上一个 <code>换行符（'\\n'）</code> 。</p>\n<p>当 puts 函数 <code>遇到</code> 字符串结尾的 <code>空字符（'\\0'）</code> 时，它会 <code>停止输出</code> ，因为空字符是 C 语言中字符串的结束标志， <code>意味着可以覆盖原本的空字符来泄露后面的内容</code></p>\n<h1 id=\"16strncmp函数\"><a class=\"anchor\" href=\"#16strncmp函数\">#</a> 16.strncmp 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">strncmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str2<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>把 str1 和 str2 进行比较，最多比较前 n 个字符。</p>\n<p>strncmp () 函数通常用于比较两个字符串，以确定它们是否相等或哪个字符串在字典顺序上更小。</p>\n<p>参数：</p>\n<ul>\n<li>str1 -- 要进行比较的第一个字符串。</li>\n<li>str2 -- 要进行比较的第二个字符串。</li>\n<li>n -- 要比较的最大字符数。</li>\n</ul>\n<p>返回值：</p>\n<ul>\n<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>\n<li>如果返回值 &gt; 0，则表示 str1 大于 str2。</li>\n<li>如果返回值 = 0，则表示 str1 等于 str2。</li>\n</ul>\n<h1 id=\"17mmap函数\"><a class=\"anchor\" href=\"#17mmap函数\">#</a> 17.mmap 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">mmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> start<span class=\"token punctuation\">,</span><span class=\"token class-name\">size_t</span> length<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> prot<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span><span class=\"token class-name\">off_t</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">munmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span> start<span class=\"token punctuation\">,</span><span class=\"token class-name\">size_t</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作用：</p>\n<p>mmap 函数将文件映射到进程地址空间，实现直接访问文件内容的功能 (mmap 函数通常用于在内存中分配一块连续的地址空间，并指定相应的权限和属性)</p>\n<p>mmap 将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap 在用户空间映射调用系统中作用很大。</p>\n<p>mmap 必须以页大小为单位进行映射，而内存也只能以页为单位进行映射，若要映射非 PAGE_SIZE 整数倍的地址范围，要先进行内存对齐，强行以 PAGE_SIZE 的倍数大小进行映射</p>\n<p><s> <code>mmap</code>  函数，它开辟了一个可执行地址，返回值就是该地址</s></p>\n<h2 id=\"2\"><a class=\"anchor\" href=\"#2\">#</a> 2</h2>\n<p>mmap () 函数的主要用途有三个：</p>\n<p>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代 I/O 读写，以获得较高的性能；</p>\n<p>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</p>\n<p>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</p>\n<h2 id=\"补充\"><a class=\"anchor\" href=\"#补充\">#</a> 补充</h2>\n<p>【尽管通过 mmap 开辟的空间没有执行权限，但是有读写权限时，仍然可以在这执行 open，read，write 等对应权限的功能】</p>\n<p>open 打开文件时设置的权限（如读写权限 O_RDWR/O_RDONLY/O_WRONLY）必须要和 mmap 系统调用所需权限相匹配。</p>\n<p>具体来说，</p>\n<p>打开时，必须允许读取，即 O_RDONLY 和 O_RDWR 至少指定一个；<br />\nmmap 调用时，如果 prot 参数中指定了 PROT_WRITE，并且 flags 中指定了 MAP_SHARED，那么打开时，必须指定 O_RDWR。<br />\n注意：</p>\n<p>1）open 时，不是所有文件都支持 mmap，如管道文件。</p>\n<p>2）mmap 完成后，关闭 fd 并不会释放内存映射对应空间，需要专门调用 munmap。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZm9ydHVuZWx5L3AvMTYyMTIwMjcuaHRtbA==\">https://www.cnblogs.com/fortunely/p/16212027.html</span></p>\n<h2 id=\"参数\"><a class=\"anchor\" href=\"#参数\">#</a> 参数</h2>\n<p>参数 start</p>\n<pre><code>指向欲映射的内存起始地址，通常设为 NULL（0），代表让系统自动选定地址，映射成功后返回该地址。\n</code></pre>\n<p>参数 length</p>\n<pre><code>代表将文件中多大的部分映射到内存。\n</code></pre>\n<p>参数 prot</p>\n<pre><code>映射区域的保护方式。可以为以下几种方式的组合：\n\nPROT_EXEC 映射区域可被执行 //1\n\nPROT_READ 映射区域可被读取 //4\n\nPROT_WRITE 映射区域可被写入//2\n\nPROT_NONE 映射区域不能存取\n</code></pre>\n<p>参数 flags</p>\n<pre><code>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。\n\nMAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此标志。\n\nMAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。\n\nMAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。\n\nMAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。\n\nMAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。\n\nMAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。\n</code></pre>\n<p>参数 fd</p>\n<pre><code>要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。\n</code></pre>\n<p>参数 offset</p>\n<pre><code>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。\n</code></pre>\n<p>返回值</p>\n<pre><code>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。\n</code></pre>\n<p>错误代码</p>\n<pre><code>EBADF 参数fd不是有效的文件描述词\n\nEACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用\n\nMAP_SHARED则要有PROT_WRITE以及该文件要能写入。\n\nEINVAL 参数start、length 或offset有一个不合法。\n\nEAGAIN 文件被锁住，或是有太多内存被锁住。\n\nENOMEM 内存不足。\n</code></pre>\n<p>需要注意的是内核并不是实时同步映射区与文件的，相反内核很少主动去同步，除非我们调用了函数 msync 或者关闭映射区（关闭映射区的时候，也不是立即同步的）</p>\n<h1 id=\"18putchar函数\"><a class=\"anchor\" href=\"#18putchar函数\">#</a> 18.putchar 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token keyword\">char</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作用：</p>\n<p>C 库函数 int putchar (int char) 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中【在屏幕上输出 char 型字符】</p>\n<p>返回值：</p>\n<p>该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。</p>\n<h1 id=\"19memset函数\"><a class=\"anchor\" href=\"#19memset函数\">#</a> 19.memset 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>C 库函数 <code>void *memset(void *str, int c, size_t n)</code>  复制字符 c（一个无符号字符）到参数 str 所指向的字符串的 <code>前 n 个字符</code></p>\n<p>参数</p>\n<ul>\n<li>str -- 指向要填充的内存块。</li>\n<li>c -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。</li>\n<li>n -- 要被设置为该值的字符数。</li>\n</ul>\n<p>返回值</p>\n<p>该值返回一个指向存储区 str 的指针。</p>\n<h1 id=\"20bzero函数\"><a class=\"anchor\" href=\"#20bzero函数\">#</a> 20.bzero () 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">bzero</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作用：</p>\n<p>bzero 函数用来将内存块（s）的前 n 个字节清零【由于 bzero 不是标准库函数，所以可移植性不是很好，建议使用 memset 函数代替】</p>\n<p>返回值：无返回值</p>\n<h1 id=\"21malloc不清空内存值\"><a class=\"anchor\" href=\"#21malloc不清空内存值\">#</a> 21.malloc (不清空内存值)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> num_bytes<span class=\"token punctuation\">)</span>；</pre></td></tr></table></figure><p>参数：</p>\n<p><code>num_byte</code>  为要申请的空间大小</p>\n<p>作用：</p>\n<p>在内存的动态存储区中分配一块长度为 size 字节的 <code>连续</code> 区域，参数 size 为需要内存空间的长度，返回该区域的首地址（首地址指的是 data 域）</p>\n<p><code>函数malloc不能初始化所分配的内存空间</code> ，这意味着我们申请的空间里面的数据仍然保留着（也就是可以通过这种方式泄露里面的数据）</p>\n<h1 id=\"22calloc清空内存值\"><a class=\"anchor\" href=\"#22calloc清空内存值\">#</a> 22.calloc（清空内存值）</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> n<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> size<span class=\"token punctuation\">)</span>；</pre></td></tr></table></figure><p>参数：</p>\n<p>其比 malloc 函数多一个参数，比如如果他要申请 20 个 int 类型空间： <code>int *p = (int *)calloc(20, sizeof(int)）</code></p>\n<p>作用：</p>\n<p>与 malloc 相似，参数 <code>sizeof(int)</code>  为申请地址的单位元素长度， <code>size_t n</code>  为元素个数，即在内存中申请 <code>sizeof(int)*size_t n</code>  字节大小的连续地址空间</p>\n<p>malloc 申请后空间的值是原来申请前的，并没有进行初始化，而 calloc 却在申请后，对空间逐一进行 <code>初始化</code> ，并设置值为 0</p>\n<h1 id=\"23realloc改变已申请的空间的大小\"><a class=\"anchor\" href=\"#23realloc改变已申请的空间的大小\">#</a> 23.realloc (改变已申请的空间的大小)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">realloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> new_Size<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>参数：</p>\n<p>ptr 为指向原来空间基址的指针， new_size 为接下来需要重新分配空间的大小</p>\n<p>作用：</p>\n<p>给一个已经分配了地址的指针重新分配空间，参数 ptr 为原有的空间地址，new_size 是重新申请的地址长度.</p>\n<p>用于对动态内存进行扩容 (及已申请的动态空间不够使用，需要进行空间扩容操作</p>\n<p>进一步分析：</p>\n<pre><code>   如果size较小，原来申请的动态内存后面还有空余内存，系统将直接在原内存空间后面扩容，并返回原动态空间基地址；如果size较大，原来申请的空间后面没有足够大的空间扩容，系统将重新申请一块&quot;原来的空间大小+新申请的空间大小&quot;的内存，并把原来空间的内容拷贝过去，原来空间free;如果size非常大，系统内存申请失败，返回NULL,原来的内存不会释放。注意：如果扩容后的内存空间较原空间小，将会出现数据丢失，如果直接realloc(p, 0);相当于free(p).\n</code></pre>\n<h1 id=\"24-brk与sbrk\"><a class=\"anchor\" href=\"#24-brk与sbrk\">#</a> 24 brk 与 sbrk</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 函数原型：</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">brk</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> <span class=\"token function\">sbrk</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">intptr_t</span> increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>brk () 和 sbrk () 改变 <code>程序间断点</code> 的位置 (申请内存空间的起始处)。程序间断点就是程序数据段的结尾。（程序间断点是为初始化数据段的起始位置）. 通过增加程序间断点进程可以更有效的申请内存 。当 addr 参数合理、系统有足够的内存并且不超过最大值时 brk () 函数将数据段结尾设置为 addr, 即间断点设置为 addr。sbrk () 将程序数据空间增加 <code>increment字节</code> 。当 <code>increment</code>  为 0 时则返回程序间断点的当前位置。</p>\n<p>也就说通过对间断点的设置来分配空间和回收内存，两个函数都能够改变间断点</p>\n<p>返回值：</p>\n<p>brk () 成功返回 0，失败返回 - 1 并且设置 errno 值为 ENOMEM（注：在 mmap 中会提到）。<br />\nsbrk () 成功返回之前的程序间断点地址。如果间断点值增加，那么这个指针（指的是返回的之前的间断点地址）是指向分配的新的内存的首地址。如果出错失败，就返回一个指针并设置 errno 全局变量的值为 ENOMEM。</p>\n<p>这两个函数都用来改变 “program break” (程序间断点) 的位置，改变数据段长度（Change data segment size），实现虚拟内存到物理内存的映射。<br />\nbrk () 函数直接修改有效访问范围的末尾地址实现分配与回收。sbrk () 参数函数中：当 increment 为正值时，间断点位置向后移动 increment 字节。同时返回移动之前的位置，相当于分配内存。当 increment 为负值时，位置向前移动 increment 字节，相当与于释放内存，其返回值没有实际意义。当 increment 为 0 时，不移动位置只返回当前位置。参数 increment 的符号决定了是分配还是回收内存</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3NkbmltZy5jbi9jSUdxWg==\">http://t.csdnimg.cn/cIGqZ</span></p>\n<h1 id=\"25fseek函数\"><a class=\"anchor\" href=\"#25fseek函数\">#</a> 25.fseek 函数（）</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">fseek</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> whence<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>C 库函数 int fseek (FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数【就是将指向文件具体位置的指针给修改位置使指向设定的偏移处】</p>\n<p>参数：</p>\n<ul>\n<li>stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>\n<li>offset -- 这是相对 whence 的偏移量，以字节为单位。</li>\n<li>whence -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一</li>\n</ul>\n<p>常量\t|    描述</p>\n<p>SEEK_SET\t|  文件的开头</p>\n<p>SEEK_CUR\t|  文件指针的当前位置</p>\n<p>SEEK_END\t|  文件的末尾</p>\n<p>返回值：</p>\n<p>如果成功，则该函数返回零，否则返回非零值。</p>\n<h1 id=\"26ftell函数\"><a class=\"anchor\" href=\"#26ftell函数\">#</a> 26.ftell 函数</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> <span class=\"token function\">ftell</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>作用：</p>\n<p>C 库函数 long int ftell (FILE *stream) 返回给定流 stream 的当前文件位置。【上面的 fseek 修改了位置，这里可以用来返回】</p>\n<p>参数：</p>\n<p>stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流</p>\n<p>返回值：</p>\n<p>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值</p>\n<h1 id=\"27空类型void\"><a class=\"anchor\" href=\"#27空类型void\">#</a> 27. 空类型 (void)</h1>\n<p>通常用于以下三种情况</p>\n<ul>\n<li>函数返回空：函数不返回值，或者返回空，例如 void exit (int status);</li>\n<li>函数参数为空：函数不接受任何参数，不带参数的函数可以接受一个 void。例如 int rand (void);</li>\n<li>指针指向 void：类型为 void * 的指针代表 <code>对象的地址</code> ，而 <code>不是类型</code> 。例如，内存分配函数 void *malloc (size_t size); 返回指向 void 的指针，可以转换为任何数据类型。</li>\n</ul>\n<h1 id=\"28pthread_creat函数创建子线程\"><a class=\"anchor\" href=\"#28pthread_creat函数创建子线程\">#</a> 28.pthread_creat 函数（创建子线程）、</h1>\n<p>pthread_create () 函数用来创建线程</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pthread_t</span> <span class=\"token operator\">*</span>thread<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                   <span class=\"token keyword\">const</span> <span class=\"token class-name\">pthread_attr_t</span> <span class=\"token operator\">*</span>attr<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>start_routine<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>各个参数的含义是：</p>\n<ol>\n<li>\n<p><code>pthread_t *thread</code> ：传递一个  <code>pthread_t</code>  类型的指针变量，也可以直接传递某个  <code>pthread_t</code>  类型变量的地址。 <code>pthread_t</code>  是一种用于表示线程的数据类型，每一个  <code>pthread_t</code>  类型的变量都可以表示一个线程。</p>\n</li>\n<li>\n<p><code>const pthread_attr_t *attr：</code> 用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 <code> NULL</code> ， <code>pthread_create()</code>  函数会采用系统默认的属性值创建线程。</p>\n</li>\n</ol>\n<p><code>pthread_attr_t </code> 类型以结构体的形式定义在 &lt;pthread.h&gt; 头文件中，此类型的变量专门表示线程的属性。</p>\n<ol start=\"3\">\n<li>\n<p><code>void *(*start_routine) (void *)：</code> 以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void* 类型。void* 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。</p>\n<p>如果该函数有返回值，则线程执行完函数后，函数的返回值可以由 pthread_join () 函数接收。</p>\n</li>\n<li>\n<p><code>void *arg</code> ：指定传递给  <code>start_routine</code>  函数的实参，当不需要传递任何数据时，将  <code>arg</code>  赋值为  <code>NULL</code>  即可。</p>\n</li>\n</ol>\n<p>返回值：</p>\n<p>如果成功创建线程， <code>pthread_create()</code>  函数返回数字 0，反之返回非零值。各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：</p>\n<ul>\n<li>EAGAIN：系统资源不足，无法提供创建线程所需的资源。</li>\n<li>EINVAL：传递给  <code>pthread_create(</code> ) 函数的 attr 参数无效。</li>\n<li>EPERM：传递给 <code> pthread_create()</code>  函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限</li>\n</ul>\n<p>以上这些宏都声明在 &lt;errno.h&gt; 头文件中，如果程序中想使用这些宏，需提前引入此头文件</p>\n<p>注意：</p>\n<p>pthread_create () 函数成功创建的线程会自动执行指定的函数，不需要手动开启。为了确保创建的线程能在主线程之前执行完，程序中可以调用 sleep () 函数延缓了主线程的执行速度。否则整个进程会随着主线程执行结束而立即终止：由于主线程执行太快，子线程可能尚未执行完就被强制终止</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLmJpYW5jaGVuZy5uZXQvdmlldy84NjA3Lmh0bWw=\">https://c.biancheng.net/view/8607.html</span></p>\n<h1 id=\"29pthread_join函数-等待线程执行结束\"><a class=\"anchor\" href=\"#29pthread_join函数-等待线程执行结束\">#</a> 29.pthread_join () 函数 【等待线程执行结束】</h1>\n<p>pthread_join () 函数声明在 &lt; pthread.h&gt; 头文件中，语法格式如下</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">pthread_join</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pthread_t</span> thread<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span> retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>thread 参数用于指定接收哪个线程的返回值；retval 参数表示接收到的返回值，如果 <code> thread</code>  线程没有返回值，又或者我们不需要接收 <code> thread</code>  线程的返回值，可以将 <code>retval</code>  参数置为 NULL。</p>\n<p><code>pthread_join() </code> 函数会一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。如果  <code>pthread_join()</code>  函数成功等到了目标线程执行结束（成功获取到目标线程的返回值），返回值为数字 0；反之如果执行失败，函数会根据失败原因返回相应的非零值，每个非零值都对应着不同的宏，例如：</p>\n<ul>\n<li>EDEADLK：检测到线程发生了死锁。</li>\n<li>EINVAL：分为两种情况，要么目标线程本身不允许其它线程获取它的返回值，要么事先就已经有线程调用  <code>pthread_join() </code> 函数获取到了目标线程的返回值。</li>\n<li>ESRCH：找不到指定的 thread 线程。</li>\n</ul>\n<p>再次强调，一个线程执行结束的返回值只能由一个  <code>pthread_join() </code> 函数获取，当有多个线程调用 <code>pthread_join()</code>  函数获取同一个线程的执行结果时，哪个线程最先执行  <code>pthread_join()</code>  函数，执行结果就由那个线程获得，其它线程的 <code>pthread_join()</code>  函数都将执行失败。</p>\n<p>对于一个默认属性的线程 A 来说，线程占用的资源并不会因为 <code>执行结束</code>  (线程自己执行结束) 而得到释放。而通过在其它线程中执行 <code>pthread_join(A,NULL);</code>  语句，可以轻松实现 “及时释放线程 A 所占资源” 的目的</p>\n<h1 id=\"30关于指针\"><a class=\"anchor\" href=\"#30关于指针\">#</a> 30. 关于指针</h1>\n<p>取值运算（ <code>*p</code> ）返回保存在 <code>内存地址为</code>  p 的内存空间中的值【 <code>*p</code>  时 p 本身会被看作为一个地址】。取地址（&amp;p）运算则返回操作数 p 的内存地址</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU2JThDJTg3JUU2JUE4JTk5XyglRTklOUIlQkIlRTglODUlQTYlRTclQTclOTElRTUlQUQlQjgp\">https://zh.wikipedia.org/zh-hans/ 指標_(電腦科學)</span></p>\n",
            "tags": [
                "pwn",
                "C语言"
            ]
        }
    ]
}