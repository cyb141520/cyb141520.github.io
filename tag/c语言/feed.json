{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog • All posts by \"c语言\" tag",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "url": "https://vvwwvv.cn/2023/08/24/pwn/c%E5%87%BD%E6%95%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E/",
            "title": "C语言函数及漏洞利用",
            "date_published": "2023-08-24T11:23:15.000Z",
            "content_html": "<p>这里用来记录在 pwn 题中一些 C 语言函数的作用和一些函数的漏洞</p>\n<h1 id=\"1-atol-atoi-atoq\"><a class=\"anchor\" href=\"#1-atol-atoi-atoq\">#</a> 1. atol、 atoi、atoq</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token function\">atol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><pre><code>atoi:  把字符串nptr转换为int\natol:  把字符串nptr转换为 long int/long long int\natoq:  \n</code></pre>\n<h1 id=\"2__readfsqword0x28u\"><a class=\"anchor\" href=\"#2__readfsqword0x28u\">#</a> 2.__readfsqword(0x28u)</h1>\n<p><strong>这段代码是通常用于 alarm 函数，防止调试</strong></p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token function\">__readfsbyte</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> <span class=\"token function\">__readfsword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token function\">__readfsdword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">unsigned</span> __int64 <span class=\"token function\">__readfsqword</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> Offset</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Offset:<br />\n[in] 从 FS 的开头开始读取的偏移量。</p>\n<p>返回值：位置 FS:[Offset] 处的字节、字、双字或四字（由调用的函数名称指示）的内存内容。</p>\n<h1 id=\"3fopenarg1agr2\"><a class=\"anchor\" href=\"#3fopenarg1agr2\">#</a> 3.fopen(&quot;arg1&quot;,&quot;agr2&quot;)</h1>\n<p>该函数原型：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FILE <span class=\"token operator\">*</span><span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>filename<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//filename-- 这是 C 字符串，包含了要打开的文件名称。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//mode-- 这是 C 字符串，包含了文件访问模式。</span></pre></td></tr></table></figure><p>功能：使用给定的模式 mode 打开 filename 所指向的文件。</p>\n<p>返回值：文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在 error 中。</p>\n<p><img data-src=\"https://z1.ax1x.com/2023/09/17/pPhGVIA.png\" alt=\"\" /></p>\n<h1 id=\"4freadbuffersizecountstream\"><a class=\"anchor\" href=\"#4freadbuffersizecountstream\">#</a> 4.fread(buffer,size,count,stream)</h1>\n<p>功能：从给定输入流 stream 读取最多 count 个对象到数组 buffer 中（相当于以对每个对象调用 size 次 fgetc），把 buffer 当作 unsigned char 数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>\n<p>返回值：</p>\n<pre><code>返回成功读取的对象个数，若出现错误或到达文件末尾，则可能小于count。\n\n若size或count为零，则fread返回零且不进行其他动作。\n\nfread不区分文件尾和错误，因此调用者必须用feof和ferror才能判断发生了什么。\n示例\n</code></pre>\n<ul>\n<li>buffer : 指向要读取的数组中首个对象的指针</li>\n<li>size : 每个对象的大小（单位是字节）</li>\n<li>count : 要读取的对象个数</li>\n<li>stream ：输入流</li>\n</ul>\n<h1 id=\"5-int-sprintfchar-string-char-format-argument\"><a class=\"anchor\" href=\"#5-int-sprintfchar-string-char-format-argument\">#</a> 5. int sprintf(char *string, char *format [,argument,...]);</h1>\n<p><code>将结果打印到字符串中，而printf是直接在命令行上输出</code></p>\n<ul>\n<li>string-- 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li>\n<li>format--format-- 这是字符串，包含了要 <code>被写入到 string 的文本</code> 。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li>\n<li>[argument]...：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li>\n</ul>\n<p>返回值：</p>\n<p>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>\n<p>sprintf 返回以 format 为格式 argument 为内容组成的结果被写入 string 的字节数，结束字符‘\\0’不计入内。即，如果 “Hello” 被写入空间足够大的 string 后，函数 sprintf 返回 5。</p>\n<pre><code>转换字符\n%% 印出百分比符号，不转换。\n%c 字符输出到缓冲区，不转换。\n%d 整数转成十进位。\n%f 倍精确度数字转成浮点数。\n%o 整数转成八进位。\n%s 字符串输出到缓冲区，不转换。\n%x 整数转成小写十六进位。\n%X 整数转成大写十六进位。\n</code></pre>\n<h1 id=\"6memchrconst-void-buf-int-ch-size_t-count\"><a class=\"anchor\" href=\"#6memchrconst-void-buf-int-ch-size_t-count\">#</a> 6.memchr(const void *buf, int ch, size_t count)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf    <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> ch    <span class=\"token punctuation\">,</span>  <span class=\"token class-name\">size_t</span> count<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>功能：从 buf 所指内存区域的前 count 个字节查找字符 ch。</p>\n<p>说明：当第一次遇到字符 ch 时停止查找。如果成功，返回指向字符 ch 的指针；否则返回 NULL。</p>\n<h1 id=\"7memcpyvoid-destin-void-source-unsigned-n\"><a class=\"anchor\" href=\"#7memcpyvoid-destin-void-source-unsigned-n\">#</a> 7.memcpy(void *destin, void *source, unsigned n)</h1>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>destin<span class=\"token punctuation\">,</span>   <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>source<span class=\"token punctuation\">,</span>    <span class=\"token keyword\">unsigned</span> n<span class=\"token punctuation\">)</span>；</pre></td></tr></table></figure><p>功能：从源 source 所指的内存地址的起始位置开始拷贝 n 个字节到目标 destin 所指的内存地址的起始位置中</p>\n<p>返回值：该函数返回一个指向目标存储区 destin 的指针。</p>\n<ul>\n<li>destin-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>\n<li>source-- 指向要复制的数据源，类型强制转换为 void* 指针。</li>\n<li>n-- 要被复制的字节数。</li>\n</ul>\n",
            "tags": [
                "pwn",
                "C语言"
            ]
        }
    ]
}