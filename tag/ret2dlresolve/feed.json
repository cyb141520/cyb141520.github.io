{
    "version": "https://jsonfeed.org/version/1",
    "title": "此时相望不相闻，愿逐月华流照君 • All posts by \"ret2dlresolve\" tag",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/10/01/pwn/%E4%B8%93%E6%A0%8F/ret2dlresolve/",
            "url": "https://vvwwvv.cn/2023/10/01/pwn/%E4%B8%93%E6%A0%8F/ret2dlresolve/",
            "title": "高级ROP之ret2dlresolve",
            "date_published": "2023-10-01T06:15:56.000Z",
            "content_html": "<p>【例题 ctfshow pwn82】</p>\n<h1 id=\"1用处\"><a class=\"anchor\" href=\"#1用处\">#</a> 1. 用处：</h1>\n<p>在有溢出而无法泄露内容时可以利用 <code>ret2dlresolve</code>  来修改解析的函数，从而达到执行想要的函数的目的</p>\n<h1 id=\"2原理\"><a class=\"anchor\" href=\"#2原理\">#</a> 2. 原理：</h1>\n<p>程序通过动态链接来达到节省空间的目的，动态链接会有一个延迟绑定的特点，将连接的过程推迟到了程序运行时</p>\n<p>动态链接中有个重要函数 <code>_dl_runtime_resolve(link_map_obj,reloc_index)</code>  来对动态链接的函数进行重定位</p>\n<pre><code>利用dl_resolve原因：\n1、dl_resolve 函数不会检查对应的函数是否越界，它只会根据我们给定的数据来执行（也就是说其可以偏移到我们构造的地方）\n2、dl_resolve 函数最后的解析根本上依赖于所给定的字符串（修改其要解析的字符串也就会调用修改后的函数）\n</code></pre>\n<p><code>dl_runtime_resolve</code>  函数只会在第一次调用这个动态链接的函数时其作用，第二次调用就不需要解析了，可以直接得到这个调用的函数的地址；<br />\n第一次调用时程序会查找需要链接的各种信息，再通过 <code>_dl_runtime_resolve</code>  将函数的真实地址写入 <code>got.plt</code>  表中</p>\n<h2 id=\"1运行_dl_runtime_resolve前\"><a class=\"anchor\" href=\"#1运行_dl_runtime_resolve前\">#</a> 1. 运行 <code>_dl_runtime_resolve</code>  前</h2>\n<p>在第一次调用动态链接函数前程序执行的是 <code>*.plt</code>  函数，其内部会执行 <code>dl_runtime_resolve</code>  来进行解析找到真实地址</p>\n<p>这里看一下第一次调用 write 函数的情况（实际上第一次调用的是 <code>write@plt</code>  的形式）利用命令 <code>objdump -d pwn82</code></p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/J3LCM3%7D8A7IR%243ZVS5%5B%7E%24%5B0.png\" alt=\"\" /></p>\n<p>得到第一次调用 write 的地址，在 gdb 中下断点 <code>b *0x80485a6</code>  ，然后运行</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/2%25E2%603020%29S%28APWNR_XA%402N.png\" alt=\"\" /></p>\n<p>si 单步进入 <code>write@plt</code>  查看情况:</p>\n<p>发现最后执行了 <code>_dl_runtime_resolve</code> ， <code>got.plt</code>  内放的是要跳转执行的下一条汇编指令地址</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/6M1%2929H%7EX_U%7EV%7B%5BBKT%60%2934D.png\" alt=\"\" /><br />\n<img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/8I%25%25MU7WYWO2ANV%299IA6UQ5.png\" alt=\"\" /></p>\n<p>分析具体调用方法：</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/RZBD1EJ%40Y3I%40_40%60%292Y17%5BM.png\" alt=\"\" /></p>\n<ol>\n<li>进入 write 自己的表项后，有个 push 0x20 是 <code>dl_runtime_resolve(link_map_obj,reloc_index)</code>  的第二个参数 `reloc_index</li>\n<li>进入公共 plt 表项 (plt0) 后，有个 push &lt;0x80498bc&gt; 就是第一个参数 <code>link_map_obj</code></li>\n</ol>\n<p>这里我们需要将 plt0 的地址覆盖到 ret 处，也就是执行了跳转，同时将 <code>dl_runtime_resolve</code>  的第一个参数 push 进栈【这么做的原因是因为我们需要利用 <code>dl_runtime_resolve</code>  函数解析执行我们需要的函数，直接 ret 进入会缺少第一个参数，用自己的 plt 表项覆盖 ret 就无法偏移到我们想要的地址】</p>\n<pre><code>这里利用ret0覆盖ret后，需要直接写入参数&quot;reloc_index&quot;,因为这是通过模拟这种方式执行write_plt等函数(可以将这两个整体视为调用了函数)，需要手动写入参数到栈上，后面就是调用write_plt的返回地址和参数\n最终也就是：p32(plt0)+p32(reloc_index)+p32(返回地址)+p32(参数1)+p32(参数2)+p32(参数3)\n</code></pre>\n<h3 id=\"疑问\"><a class=\"anchor\" href=\"#疑问\">#</a> 疑问</h3>\n<p>为什么要以 <code>plt0</code>  覆盖 ret，而不直接用 <code>dl_runtime_resolve</code>  来覆盖</p>\n<p>因为需要填充 <code>dl_runtime_resolve</code>  的参数，而我们执行 <code>plt0</code>  就不需要填充第一个参数了，而第二个参数是我们需要控制的所以需要自己填充</p>\n<h2 id=\"2执行_dl_runtime_resolve\"><a class=\"anchor\" href=\"#2执行_dl_runtime_resolve\">#</a> 2. 执行 <code>_dl_runtime_resolve</code></h2>\n<p>在上面的两个 push 中将 <code>_dl_runtime_resolve</code>  的两个参数压入栈中，然后就进入 <code>_dl_runtime_resolve</code>  来执行</p>\n<p>其内部过程为 (借用大佬的图)：</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/V%60%28342LD_94ZQ%7BI%5DN%5DV%5B%7EWA.png\" alt=\"\" /></p>\n<p>通过上面的图可以看到以第二个参数为准，然后一步一步相加计算得到要解析的函数名</p>\n<h3 id=\"第一步得到reloc_index\"><a class=\"anchor\" href=\"#第一步得到reloc_index\">#</a> 第一步：得到 reloc_index</h3>\n<p>利用第二个参数与 <code>.rel.plt</code>  相加，那么就可以得到调用的函数的具体 <code>.rel.plt</code>  结构体情况：</p>\n<p>.rel.plt 结构体：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  Elf32_Addr r_offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  Elf32_Word r_info<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span>Elf32_Rel</pre></td></tr></table></figure><p>从上面的 <code>.rel.plt</code>  结构体来看， <code>.rel.plt</code>  重定位表 是保持了所有函数的这个结构体信息（每个结构体 8 字节），而不仅仅是起到一个索引的作用</p>\n<p>因此用 <code>.rel.plt</code>  的基地址加上 <code>偏移</code> 就为所要函数的 <code>Elf32_Rel</code>  指针，然后就得到了对应的 <code>r_offset</code>  和 <code>r_info</code></p>\n<p><code>.rel.plt</code>  存放内容 (命令 <code>readelf -x .rel.plt 程序名</code> )：</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/TYY7DHBU_3%5D%40MSM_C5I2JCM.png\" alt=\"\" /></p>\n<p>我们的重点就是在这个 <code>偏移</code> 如何得到：</p>\n<p>上面可以知道在执行时，第二次跳转到 <code>plt0</code>  (.plt 表的头部)，而我们需要的是 <code>.rel.plt</code>  这里就有一个对应的关系（这里就要计算得函数是.plt 的第几个结构体，）</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/%28ZI0%5BH%7BC5UX9KC%60TES_%2864Q.png\" alt=\"\" /></p>\n<p>上面可以看到，对应结构体开始在 <code>.plt</code>  中是从下标 1 开始，而在 <code>.rel.plt</code>  中是从下标 0 开始，也就是说如果 write 结构体是结构体 5，那么在 <code>.rel.plt</code>  中就是结构体 4</p>\n<p><code>.plt</code>  存放内容 (命令 <code>readelf -x .plt 程序名</code> )：</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/J%25EK%60RH8%5B5%25NNGKG%7DI3M0%5B5.png\" alt=\"\" /></p>\n<p>通过上面的对应关系知道，我们想要找 write 在 <code>.rel.plt</code>  重定位索引就要通过 plt 来得到，由 <code>.plt</code>  与 <code>.rel.plt</code>  的对应关系知道： <code>plt结构体-1=rel.plt结构体</code> ，所以这里计算在.plt 中是第几个结构体：</p>\n<pre><code>write_plt-plt[0]=offset    //这里plt[0]地址可以通过pwntools得到\noffset/16=是plt表中的第几个结构体\nplt结构体-1=rel.plt结构体\n因为.rel.plt结构体的大小为8字节，所以还要乘8(这里得到的值是相对偏移)\n\n也就是：\nwrite_index = [（write_plt-plt[0]）/16 -1] * 8（write_index就是与.rel.plt的偏移，也就是reloc_index）【不过其实这个计算再后面伪造时用不到，因为偏移通过后面伪造的地址减基地址就得到了】\n\n</code></pre>\n<h2 id=\"第二步伪造relplt结构体\"><a class=\"anchor\" href=\"#第二步伪造relplt结构体\">#</a> 第二步：伪造 <code>.rel.plt</code>  结构体</h2>\n<p>上面知道 <code>write_index</code>  知道，这是与 <code>.rel.plt</code>  的偏移；但是在 <code>dl_resolve</code>  执行时并没有检查边界，所以我们可以将这个偏移任意修改，因此可以修改其偏移到到我们伪造的 <code>.rel.plt</code>  结构体，可以构建式子：</p>\n<pre><code>rel.plt+write_index=fake_struck_rel_plt\n\n所以：\nwrite_index=fake_strunk_rel_plt-rel.plt\n\n</code></pre>\n<p>然后需要考虑在偏移的地方来伪造对应的结构体：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  Elf32_Addr r_offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  Elf32_Word r_info<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span>Elf32_Rel</pre></td></tr></table></figure><p>这个结构体有两个成员变量需要伪造，第一个是 <code>r_offset</code> ，这个可以通过 pwntools 的 ELF 功能自动获得，也就是 <code>write_got=elf.got[&quot;write&quot;]</code> ；第二个成员变量 <code>r_info</code>  需要自己查看 <code>readelf -a 程序名</code> ，如下：</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/BQV2YETO9H51Z6PB%29HJ%5BG%5B9.png\" alt=\"\" /></p>\n<p>看下面的图可以知道， <code>r_info</code>  右移一个字节，以上图中的 <code>607</code>  的 6 作为.dynsym 下标，寻找.dynsym 的标号为 6 结构体 (下标以 0 开始)</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/V%60%28342LD_94ZQ%7BI%5DN%5DV%5B%7EWA.png\" alt=\"\" /></p>\n<h2 id=\"第三步构造动态符号表-dynsymr_info8\"><a class=\"anchor\" href=\"#第三步构造动态符号表-dynsymr_info8\">#</a> 第三步：构造动态符号表  <code>dynsym+(r_info&gt;&gt;8)</code></h2>\n<p>dynsym 结构体：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  Elf32_Word    st_name<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 符号名，是相对.dynstr 起始的偏移</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  Elf32_Addr    st_value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  Elf32_Word    st_size<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> st_info<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 对于导入函数符号而言，它是 0x12</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> st_other<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  Elf32_Section st_shndx<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span>Elf32_Sym<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 对于导入函数符号而言，除 st_name 外其他字段都是 0</span></pre></td></tr></table></figure><p>所以根据该结构体，我们要伪造的结构体样子大致为 <code>[name偏移，0，0，0x12]</code></p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/J52%60QY%29Q4AT0HNC9%5DR8OWR9.png\" alt=\"\" /></p>\n<p>l 利用命令 <code>readelf -a pwn82</code>  找到 <code>.dynsym</code>  符号表，可以看到 write 对应的是下标 <code>Num=6</code></p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/S%40Z%5DT16%7ELH_M4%24QEQGURG%29Y.png\" alt=\"\" /></p>\n<p>接下来查看具体 write 的 <code>.dynsym</code>  结构体：</p>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/Y%5D%298I%60C4%29MQK44S%40%7E9OJGQA.png\" alt=\"\" /></p>\n<p>其结构体就是 <code>[0x4c,0,0,0x12]</code> （当然这里的 0x4c 可以被改变，这就达到解析其他字符串的目的），而在 <code>dynsym+(r_info&gt;&gt;8)</code>  也就是得到了该结构体，我们可以修改 <code>r_info</code>  使下标指向到我们伪造的 <code>dynsym</code>  结构体处</p>\n<p>伪造 <code>.dynsym</code>  结构体：</p>\n<p>因为 <code>.dynsym</code>  的每个结构体大小是 16 字节，那么我们就需要满足其是 16 字节对齐的（因为这里是以下标的形式索引每次只能 16 字节的查找，其他的直接用偏移所以不用担心对齐），利用公式使其满足 16 字节对齐：</p>\n<pre><code>fake_sym_addr = base_stage + 32 //伪造结构体的地址\nalign = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)   //计算是否是16字节对齐\nfake_sym_addr = fake_sym_addr + align //使完成16字节对齐\n</code></pre>\n<h3 id=\"疑问1\"><a class=\"anchor\" href=\"#疑问1\">#</a> 疑问 1</h3>\n<pre><code>0x10 - ((0x8048a88 - 0x8048a00) &amp; 0xf) = 0x10 - 0x8 = 0x8\n\n距离初始的偏移，然后与0xf查看最后一16进制位的值，0x10来看其满足16进制对齐还有多少距离\n</code></pre>\n<p>接下来利用伪造的 <code>.dynsym结构体</code> 来反推 <code>r_info</code> :</p>\n<p>我们知道 <code>dynsym+(r_info&gt;&gt;8)=write结构体地址</code>  ，而在我们伪造的结构体下已知了结构体地址，所以:</p>\n<pre><code>index_dynsym = (fake_sym_add-dynsym ) / 0x10（间隔的结构体个数）\nr_info=(index_dynsym&lt;&lt;8)+0x07\n</code></pre>\n<p>这里得到的 <code>r_info</code>  就可以在前面伪造的 <code>.rel.plt</code>  结构体处使用这个值（ <code>r_offset</code>  不用改变）</p>\n<h2 id=\"第四步构造动态字符表dynstr\"><a class=\"anchor\" href=\"#第四步构造动态字符表dynstr\">#</a> 第四步：构造动态字符表 (.dynstr)</h2>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/%E4%B8%93%E6%A0%8F/ret2dlresolve/QP%7B4V_ZZ%24I1%5D2W%5D%298%24%286%7BPO.png\" alt=\"\" /></p>\n<p>这里我们需要构造两部分</p>\n<ol>\n<li>构造 <code>.dynstr</code>  动态字符表 (也就是部署 <code>write\\x00</code>  这个字符串去解析)</li>\n<li>修改第三步中的 <code>.dynsym</code>  结构体的 <code>str_name</code>  这个偏移量（使能够找到 write 字符串）</li>\n</ol>\n<p>首先就是部署 <code>write\\x00</code>  字符串，得到这个的地址记为 <code>fake_write_addr</code> ，接下来计算偏移  <code>str_name=fake_write_addr-dynstr</code>  ，最后将第三步中的 <code>dynsym</code>  结构体伪造成 <code>[str_name，0，0，0x12]</code></p>\n<h2 id=\"第五步getshell\"><a class=\"anchor\" href=\"#第五步getshell\">#</a> 第五步：getshell</h2>\n<p>上面部署的是 <code>write\\x00</code>  字符串，那么我们下面将其部署成 <code>system\\x00</code>  就可以了，而 write 函数的三个参数中，将第一个参数修改为 <code>/bin/sh\\x00</code>  就能 getshell</p>\n<h1 id=\"3总结\"><a class=\"anchor\" href=\"#3总结\">#</a> 3. 总结：</h1>\n<p><code>ret2dlresolve</code>  是在无法泄露地址得到 libc 的情况下使用，这里是通过调用其他函数的 plt，之后在解析时解析我们想要执行的函数名即可</p>\n<h3 id=\"执行流程\"><a class=\"anchor\" href=\"#执行流程\">#</a> 执行流程:</h3>\n<p>1. 首先通过重定位索引 <code>reloc_index</code>  来确定需要的函数在重定位表 <code>.rel.plt</code>  的偏移是多少，以此来找到对应的 <code>Elf32_Rel</code>  结构体</p>\n<p>构造步骤：</p>\n<ol>\n<li>部署字符串（要执行的函数名，如 <code>system\\x00</code> ）</li>\n<li>通过 <code>字符串地址-dynstr基地址</code>  得到 dynsym 结构体中第一个成员变量的值（也就是字符串的偏移）</li>\n<li>部署伪造的 system 的 <code>.dynsym</code>  结构体，其中第一个成员变量要用 <code>步骤2</code>  的值</li>\n<li>由伪造的 <code>system</code>  结构体地址 - dynsym 基地址 = 偏移，利用该偏移得到 <code>r_info</code>  ((偏移 / 0x10&lt;&lt;8)+0x7)</li>\n<li>伪造 <code>rel.plt</code>  结构体，通过上面的 <code>r_info</code>  作为其第二个成员变量（第一个成员变量为 <code>write_got</code>  等）</li>\n<li>利用伪造的 <code>rel.plt</code>  结构体地址 - rel.plt 基地址 = <code>reloc_index</code> ，得到的 <code>reloc_index</code>  就是 <code>dl_runtime_resolve</code>  第二个参数，第一个参数是 <code>link_map_obj</code>  在前面利用 <code>plt0</code>  覆盖 ret 后就直接 push 进栈了</li>\n</ol>\n<h2 id=\"疑问1-2\"><a class=\"anchor\" href=\"#疑问1-2\">#</a> 疑问 1</h2>\n<p>有个疑问，为什么要分成三个表，直接是动态字符串表加偏移不行吗</p>\n<p>个人觉得这是为了节省一定的资源，能够缩小一定的查找范围</p>\n<h2 id=\"疑问2\"><a class=\"anchor\" href=\"#疑问2\">#</a> 疑问 2</h2>\n<p><code>.plt0</code> 、 <code>.rel.plt</code> 、 <code>.dynsym</code> 、 <code>.dynstr</code>  的基地址怎么找：</p>\n<pre><code>plt0=elf.get_section_by_name(&quot;.plt&quot;).header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n\n</code></pre>\n<h2 id=\"疑问3\"><a class=\"anchor\" href=\"#疑问3\">#</a> 疑问 3</h2>\n<p>r_offset 的作用是什么，好像除了保持函数在 got 表的偏移就没有用了，这个偏移也就是 <code>write_got = elf.got['write']</code>  ，个人理解其作用是将 write 函数填入，不直接填入 system 是因为没有调用 <code>system_plt</code> ，通过这种方式进入 <code>dl_runtime_resolve</code>  最后改将解析的 write 变为 system 即可</p>\n<h2 id=\"疑问4\"><a class=\"anchor\" href=\"#疑问4\">#</a> 疑问 4</h2>\n<p>r_offset 是 <code>write_got = elf.got['write']</code>  而再调用过 write_plt 和未调用过 write_plt 情况下 <code>write_got</code>  是否相同？</p>\n<p>第一次调用时才进行解析，后面调用时 write_got 里直接存放的是真实地址，那么我认为 r_offset 保持的不是真实地址，而是第一次调用时需要的偏移（那么我们再构造的时候用 write_got 是不是就有问题，因为感觉不是第一次调用得到的偏移）</p>\n<h2 id=\"注意的点\"><a class=\"anchor\" href=\"#注意的点\">#</a> 注意的点</h2>\n<p>.dynsym 结构体下标以 0 开始 (其实就是除了 plt 之外其他的结构体但是从 0 开始的，因为 plt0 相当于作为头部了)</p>\n<p>flat 函数是 pwn 模块的功能：将多个变量转化为二进制字符串</p>\n<p>payload=pwn.flat([v1,v2,v3])</p>\n<p>v1,v2,v3 是加入到 payload 的变量，相当于 v1+v2+v3</p>\n<h1 id=\"还要注意\"><a class=\"anchor\" href=\"#还要注意\">#</a> 还要注意</h1>\n<p>我们执行的 plt [0] 等，需要是在迁移后的栈上执行，这里直接覆盖 ret 貌似有点问题</p>\n<h1 id=\"4例题pwn82\"><a class=\"anchor\" href=\"#4例题pwn82\">#</a> 4. 例题（pwn82）</h1>\n<h2 id=\"1程序信息\"><a class=\"anchor\" href=\"#1程序信息\">#</a> 1. 程序信息：</h2>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/ctfshow/1GWJ%25618SAICLB%7B%24K%25%299G2V.png\" alt=\"\" /></p>\n<p><code>main()函数</code> ：<br />\n<img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/ctfshow/%29%5D783B7I%246R%7D6OMAM06%5BKAG.png\" alt=\"\" /></p>\n<p><code>show()函数：</code> <br />\n<img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/ctfshow/8ZK%40%7BDO%24LJ1R%5D0H4H9ODK6T.png\" alt=\"\" /></p>\n<p>可以看到 read 函数能溢出，因为这道题有 write 函数，所以我们可以利用 ret2libc，但是这里换个方式用 <code>ret2dlresolve</code>  解决</p>\n<h2 id=\"2分析\"><a class=\"anchor\" href=\"#2分析\">#</a> 2. 分析</h2>\n<p>通过上面的原理我们知道，需要构造一系列的结构体然后利用 <code>_dl_runtime_resolve</code>  的第二个参数 <code>reloc_index</code>  来最终通过构造的结构体找到想执行的函数名去解析 执行</p>\n<p>而由于我们的构造的结构体内容需要指向后面构造的内容所以我们可以从后往前构造：</p>\n<h3 id=\"1首先确定name_offset\"><a class=\"anchor\" href=\"#1首先确定name_offset\">#</a> 1. 首先确定 <code>name_offset</code></h3>\n<p><img data-src=\"https://vvwwv.oss-cn-nanjing.aliyuncs.com/ctfshow/DSOYLEN9%5B162E3F2RRGJ%5BMA.png\" alt=\"\" /></p>\n<p>将构造的 <code>system</code>  输入到 bss 段上</p>\n<p>b&quot;a&quot;+read+p32(0)+p32(0x804+4)+p32(4)+read(0,98e0,len(dynstr))+read(0,8e0+0x100,len(&quot;/bin/sh&quot;))+p32(0x8048376 plt0)+p32(0xdeadbeff)+p32(0x80498e0+0x100)</p>\n",
            "tags": [
                "ret2dlresolve"
            ]
        }
    ]
}